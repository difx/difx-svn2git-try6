#!/bin/env python

#**************************************************************************
#   Copyright (C) 2009 by Walter Brisken                                  *
#                                                                         *
#   This program is free software; you can redistribute it and/or modify  *
#   it under the terms of the GNU General Public License as published by  *
#   the Free Software Foundation; either version 3 of the License, or     *
#   (at your option) any later version.                                   *
#                                                                         *
#   This program is distributed in the hope that it will be useful,       *
#   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
#   GNU General Public License for more details.                          *
#                                                                         *
#   You should have received a copy of the GNU General Public License     *
#   along with this program; if not, write to the                         *
#   Free Software Foundation, Inc.,                                       *
#   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
#**************************************************************************

#===========================================================================
# SVN properties (DO NOT CHANGE)
#
# $Id$
# $HeadURL$
# $LastChangedRevision$
# $Author$
# $LastChangedDate$
#
#============================================================================

from sys import argv, exit
from string import split, strip
from glob import glob
from os import getenv, mkdir, chdir, system, getcwd, rmdir
from os.path import isfile, isdir, getsize
from time import gmtime, time

program = 'makefits'
version = '0.2'
author  = 'Walter Brisken'
verdate = '20090421'

calFiles = ['flag', 'pcal', 'tsys', 'weather']

def usage(prog):
	print '\n%s ver %s  %s  %s' % (program, version, author, verdate)
	print '\nUsage:  %s [options] <pass name>' % prog
	print '\nOptions can include:'
	print '  --verbose'
	print '  -v         Send more output to the screen\n'
	print '  --help'
	print '  -h         Print this help information and quit\n'
	print '  --override-version'
	print '             To force operation with mixed DiFX versions\n'
	print '  --allow-partial'
	print '             Bypass check for complete set of correlated\n'
	exit(0)

def parsekv(str):
	kv = {}
	ss = split(str)
	for s in ss:
		p = split(s, '=')
		if len(p) != 2:
			print 'Error parsing key=value statement: %s', s
			return {}
		kv[p[0]] = p[1]
	return kv

# turn unix time into mjd.  Should only be used when precision is not required
def getmjd(t):
	return 40587.0 + t/86400.0

def mergesnifferfiles(expt, list, passname, ext, cwd, verbose, hasHeaderLine):
	dir = cwd + '/sniffer'
	
	if not isdir(dir):
		mkdir(dir)

	outfile = '%s/%s.%s.%s' % (dir, expt, passname, ext)
	if isfile(outfile):
		system('mv %s %s.old' % (outfile, outfile))
	skipFirst = False

	files = []
	for i in list:
		infile = '%s.%d.%s' % (expt, i, ext)
		if isfile(infile):
			files.append(infile)
		else:
			print 'Warning: %s not found' % infile

	if len(files) == 0:
		print 'No %s files to merge!' % ext
		return

	out = open(outfile, 'w')

	if verbose:
		print '\nMaking sniffer file %s from:' % outfile
	
	for infile in files:
		if verbose:
			print '  %s' % infile
		data = open(infile, 'r').readlines()
		if skipFirst == False:
			skipFirst = hasHeaderLine
			out.write(data[0])
		for d in data[1:]:
			out.write(d)
		system('rm %s' % infile)
	out.close()

def genDateStr(t):
	d = gmtime(t)
	return '%02d%02d%02dT%02d%02d%02d' % \
		(d.tm_year % 100, d.tm_mon, d.tm_mday, \
		d.tm_hour, d.tm_min, d.tm_sec)

class Job:
	def __init__(self, str):
		s = split(strip(str))
		if len(s) >= 4:
			self.name = s[0]
			self.mjdStart = float(s[1])
			self.mjdStop = float(s[2])
			self.nAnt = int(s[3])
		else:
			self.name = ''
	def show(self, indent=0):
		print '%sJob %s: start=%f stop=%f nAnt=%d' % \
			(' '*indent, self.name, self.mjdStart, self.mjdStop, self.nAnt)
	def verify(self, dir):
		files = ['.calc', '.input', '.flag', '.im']
		for f in files:
			file = dir + '/' + self.name + f
			if not isfile(file):
				print '%s not found' % file
				return False
		ddir = dir + '/' + self.name + '.difx'
		if not isdir(ddir):
			print 'difx output dir %s not found' % ddir
			return False
		return True

class JobList:
	def __init__(self, filename):
		self.filename = filename
		data = open(filename).readlines()
		self.jobs = []
		if len(data) < 2:
			print 'Malformed .joblist file %s' % filename
			exit(0)
		self.kv = parsekv(data[0])
		if len(self.kv) < 1:
			print 'Malformed .joblist file %s line 1' % filename
			exit(0)
		for n in range(1, len(data)):
			d = split(data[n], '#')[0]
			if len(d) < 2:
				continue
			j = Job(d)
			if j.name == '':
				print 'Malformed line %d in %s' % (n+1, filename)
				exit(0)
			self.jobs.append(j)
	
	def testversion(self, override):
		difxVersion = getenv('DIFX_VERSION')
		if difxVersion == None:
			print 'Warning: env var DIFX_VERSION is not set!'
			if override:
				difxVersion = 'unknown'
			else:
				exit(0)
		elif difxVersion != self.kv['DiFX']:
			if override:
				print 'Overriding version mismatch: %s != %s' % \
					(difxVersion, self.kv['DiFX'])
				difxVersion = 'unknwown'
			else:
				print 'Error: file DiFX version = %s' % self.kv['DiFX']
				print 'and current DiFX version = %s' % difxVersion
				exit(0)

		self.kv['DiFX'] = difxVersion

		return difxVersion

	def makefits(self, queuedir, verbose, sniff, options=''):
		dir = queuedir + '/' + self.kv['exper']
		cwd = getcwd()
		
		t = time()

		datestr = genDateStr(t)

		tmp = dir + '/' + 'makefilts.tmp'
		if isdir(tmp):
			print '\nError: temporary directory %s already exists.  Aborting.' % tmp
			exit(0)
		mkdir(tmp)

		calfiles = ''
		for f in calFiles:
			if not isfile(f):
				print 'Warning: file "%s" not in current directory.' % f
			else:
				calfiles = calfiles + ' ' + f
		if len(calfiles) > 0:
			cmd = 'cp %s %s' % (calfiles, tmp)
			if verbose:
				print 'Executing: %s' % cmd
			system(cmd)

		if verbose:
			print 'Changing to directory: %s' % tmp
		chdir(tmp)

		cmd = 'difx2fits %s ' % options
		for j in self.jobs:
			cmd += ('../%s ' % j.name)
		if verbose:
			print 'Executing: %s' % cmd
		system(cmd)
		
		files = glob('*.*.FITS')
		if len(files) == 0:
			print 'Error: No fits files made'
			print 'Please clean remove %s when you are done picking up the pieces.' % tmp
			exit(0)
		if verbose:
			print 'Made %d FITS files' % len(files)
		
		expt = split(files[0], '.')[0]

		indices = []
		for f in files:
			s = split(f, '.')
			if s[0] != expt:
				print 'Error: Unexpected variety of FITS files found:', files
				print 'Please clean remove %s when you are done picking up the pieces.' % tmp
				exit(0)
			indices.append(int(s[1]))

		indices.sort()

		j = 1
		out = open('%s/%s.fitslist' % (cwd, self.kv['pass']), 'w')
		out.write('exper=%s  pass=%s  jobs=%s  mjd=%9.7f  DiFX=%s  difx2fits=0\n' % \
			(self.kv['exper'], self.kv['pass'], self.filename, getmjd(t), self.kv['DiFX']))
		for i in indices:
			fn = '%s.%d.FITS' % (expt, i)
			size = getsize(fn)/1000000.0
			archfile = 'VLBA_%s_%s_%d_%s.idifits' % \
				(self.kv['exper'], self.kv['pass'], j, datestr)
			out.write('%s %3.1f %s\n' % (archfile, size, fn))
			if verbose:
				print 'mv  %s -> ../%s' % (fn, archfile)
			cmd = 'mv %s ../%s' % (fn, archfile)
			system(cmd)
			j = j + 1
		out.close()

		# merge and gzip difxlog files
		logFile = '%s/%s.difxlog' % (cwd, self.kv['pass'])
		cmd = 'cat'
		nLog = 0
		for j in self.jobs:
			fn = dir + '/' + j.name + '.difxlog'
			if isfile(fn):
				cmd = cmd + ' ' + fn
				nLog += 1
		if nLog > 0:
			cmd = cmd + ' > ' + logFile
			if verbose:
				print 'Executing: %s' % cmd
			system(cmd)
			cmd = 'gzip -f %s' % (logFile)
			if verbose:
				print 'Executing: %s' % cmd
			system(cmd)
		else:
			if verbose:
				print 'No .difxlog files to merge'

		# merge sniffer files
		if sniff:
			for x in [['acb', False] , ['apd', True], ['log', False], ['wts', True], ['xcb', False]]:
				mergesnifferfiles(expt, indices, self.kv['pass'], x[0], cwd, verbose, x[1])

		if len(calfiles) > 0:
			cmd = 'rm %s' % calfiles
			if verbose:
				print 'Executing: %s' % cmd
			system(cmd)

		chdir(cwd)

		if len(glob('%s/*' % tmp)) == 0:
			rmdir(tmp)
		
		if isdir(tmp):
			print 'Warning: unexpected files left in %s' % tmp

		return True

	def verify(self, queuedir, allowPartial):
		dir = queuedir + '/' + self.kv['exper']

		completeJobs = []

		OK = True
		for j in self.jobs:
			if j.verify(dir) == False:
				OK = False
			else:
				completeJobs.append(j)
		if not allowPartial:
			return OK

		nFail = len(self.jobs) - len(completeJobs)
		if nFail == 0:
			return True

		if len(completeJobs) == 0:
			print 'No jobs are complete.  Cannot continue'
			return False

		print '%d of %d jobs were not complete.  Continuing anyway...' % \
			(nFail, len(self.jobs))
		self.jobs = completeJobs
		return True

	def show(self, indent=0):
		id = ' '*indent
		print '%sJobList: %s' % (id, self.filename)
		id = ' '*(indent+2)
		for key in self.kv.keys():
			print '%sKV: %s = %s' % (id, key, self.kv[key])
		for j in self.jobs:
			j.show(indent+2)

difxQueueBase = getenv('DIFX_QUEUE_BASE')
if difxQueueBase == None:
	print 'Error: env var DIFX_QUEUE_BASE is not set.  Cannot proceed.'
	exit(0)

overrideVersion = False
allowPartial = False
verbose = False
sniff = True

opts = ''
args = []
for a in argv[1:]:
	if a[0] == '-':
		if a == '--override-version':
			overrideVersion = True
		elif a == '--allow-partial':
			allowPartial = True
		elif a in ('-h', '--help'):
			usage(argv[0])
			opts = opts + ' -v'
		else:
			opts = opts + ' ' + a

		if a in ('-v', '--verbose'):
			verbose = True
		if a in ('-x', '--dont-sniff'):
			sniff = False
	else:
		args.append(a)

if opts == '':
	opts = '-v'

if len(args) < 1:
	usage(argv[0])

for arg in args:
	if arg[-8:] == '.joblist':
		joblistfile = arg
	else:
		joblistfile = arg + '.joblist'

	if not isfile(joblistfile):
		print 'Error: file %s not found' % joblistfile
		exit(0)

	jl = JobList(joblistfile)

	jl.testversion(overrideVersion)

	if verbose:
		jl.show()

	OK = jl.verify(difxQueueBase, allowPartial)

	if not OK:
		if not allowPartial:
			print 'job list verification failed!'
		exit(0)

	OK = jl.makefits(difxQueueBase, verbose, sniff, opts)
