/*
 * This is an expansion of the FormattedTextField that implements tab completion.
 * It traps user tab entries and sends an "ls" instruction to the DiFX host based
 * on the content of the text field.  Any unique text is filled in.  The list of
 * items returned by the "ls" is maintained.  A "newList" callback is generated
 * when the "ls" returns its results.
 */
package edu.nrao.difx.difxutilities;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.event.EventListenerList;

import java.util.ArrayList;
import java.util.Iterator;
import java.awt.Cursor;

import mil.navy.usno.widgetlib.FormattedTextField;

import edu.nrao.difx.difxview.SystemSettings;

public class TabCompletedTextField extends FormattedTextField {
    
    public TabCompletedTextField( SystemSettings settings ) {
        super();
        _settings = settings;
        this.addTabListener( new ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                doTabCompletion();
            }
        });
        _this = this;
        _currentList = new ArrayList<String>();
        _newListListeners = new EventListenerList();
    }
    
    public void doTabCompletion() {
        _currentList.clear();
        final Cursor cursor = this.getCursor();
        this.setCursor( Cursor.getPredefinedCursor( Cursor.WAIT_CURSOR ) );
        DiFXCommand_ls ls = null;
        if ( _this.getText().endsWith( "*" ) )
            ls = new DiFXCommand_ls( _this.getText().trim(), _settings );
        else
            ls = new DiFXCommand_ls( _this.getText().trim() + "*", _settings );
        ls.addEndListener( new ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                _this.setCursor( cursor );
                //  Found anything at all?
                if ( _currentList.size() > 0 ) {
                    Iterator<String> iter = _currentList.iterator();
                    String commonString = iter.next();
                    for ( ; iter.hasNext(); ) {
                        String newStr = iter.next();
                        int i = 0;
                        while ( commonString.regionMatches( 0, newStr, 0, i ) )
                            ++i;
                        if ( i > 0 )
                            commonString = commonString.substring( 0, i - 1 );
                        else
                            commonString = "";
                    }
                    //  The common string becomes the new text...
                    _this.setText( commonString );
                    _this.setCaretPosition( commonString.length() );
                }
                newListCallback();
            }
        });
        ls.addIncrementalListener( new ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                _currentList.add( e.getActionCommand().trim() );
            }
        });
        try {
            ls.send();
        } catch ( java.net.UnknownHostException e ) {
            //  BLAT handle this
        }
    }
    
    //  This returns the most recent list of items generated by tab completion.
    public ArrayList<String> currentList() {
        return _currentList;
    }
   
    public void addNewListListener( ActionListener a ) {
        _newListListeners.add( ActionListener.class, a );
    }

    public void newListCallback() {
        Object[] listeners = _newListListeners.getListenerList();
        int numListeners = listeners.length;
        for ( int i = 0; i < numListeners; i+=2 ) {
            if ( listeners[i] == ActionListener.class )
                ((ActionListener)listeners[i+1]).actionPerformed( new ActionEvent( this, ActionEvent.ACTION_PERFORMED, this.getText() ) );
        }
    }

    public ArrayList<String> _currentList;
    protected EventListenerList _newListListeners;
    protected TabCompletedTextField _this;
    protected SystemSettings _settings;
 
}
