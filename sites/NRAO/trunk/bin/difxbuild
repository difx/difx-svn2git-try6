#!/usr/bin/env python

from os import environ, system, getcwd, chdir, popen, readlink
from os.path import isdir, isfile, islink, join, dirname
from sys import argv, exit, platform
from re import search
import getopt
from string import split, strip, find, lower
import platform
from time import asctime

program = 'difxbuild'
version = '0.11'
verdate = '20120720'
author = 'Walter Brisken <wbrisken@nrao.edu>'

openmpiVersion = '1.6'
pgplotVersion = '5.2'
numMakeCpus = 4


def getippversion(path):
	if islink(path):
		path = join(dirname(path), readlink(path))
# First try ippversion.h
        ippheader = path+'/include/ippversion.h'
	if not isfile(ippheader):
		ippheader = path+'/ipp/include/ippversion.h'
		if not isfile(ippheader):
			ippheader = ''

	if (ippheader==''):
		print "Warning: ippversion.h not found, relying on IPP path ", path
		s = split(path, '/')
		possibilities = []
		for part in s:
			t = split(part, '.')
			if len(t) > 1:
				possibilities.append(part)
				if len(possibilities) < 1:
					print 'Sorry, cannot determine ipp version from path'
					exit(0)
					if len(possibilities) > 1:
						print 'Guessing version == %s' % possibilities[-1]

						return possibilities[-1]
					
	else:
		print "Reading version from ", ippheader
		major = minor = None
		for line in open(ippheader):
			m = search('#define\s+IPP_VERSION_STR\s+"(\S+)"', line)
			if (m != None):
				print "Got version ", m.group(1)
				return m.group(1)
			if (major == None):
			    major = search('#define\s+IPP_VERSION_MAJOR\s+(\S)', line)
			if (minor == None):
			    minor = search('#define\s+IPP_VERSION_MINOR\s+(\S)', line)
		if (major != None and minor != None):
			print "Have version ", major.group(1) + "." + minor.group(1)
			return major.group(1) + "." + minor.group(1)
		print "Sorry, cannot find IPP_VERSION_STR in ", ippheader
		exit(0)
	
# fixme: possibly should use uname to get this information
def getarch():
	bs = environ['DIFXBITS']
	if bs != None:
		return int(bs)
	else:
		print 'Warning: defaulting to 32 bit assumption'
		return 32

def genipppc(path):
	ippversion = getippversion(path)
	ipparch = getarch()

	major = int(split(ippversion, '.')[0])
	out = open('ipp.pc', 'w')
	out.write('base = %s\n' % path)
	out.write('\n')
	out.write('Name: ipp\n')
	out.write('Description: Intel Performance Primitives\n')
	out.write('Requires:\n')
	out.write('Version: %s\n' % ippversion)
	
	mac = False
	if platform == "darwin":
		mac = True

	if major == 6 or major == 5:
		if mac:
			libdir = 'Libraries'
		else:
			libdir = 'sharedlib'
		if ipparch == 32:
			out.write('Libs: -Wl,-rpath,${base}/%s -L${base}/%s -lipps -lguide -lippvm -lippcore\n' % (libdir, libdir))
			out.write('Cflags: -I${base}/include\n')
		else:
			out.write('Libs: -Wl,-rpath,${base}/%s -L${base}/%s -lippsem64t -lguide -lippvmem64t -lippcoreem64t\n' % (libdir, libdir))
			out.write('Cflags: -I${base}/include\n')
	elif major == 7:
		if ipparch == 32:
			libdir = 'ia32'
		else:
			libdir = 'intel64'
		out.write('Libs: -L${base}/lib/%s -L${base}/ipp/lib/%s -lipps -lippvm -lippcore -liomp5\n' % (libdir, libdir))
		out.write('Cflags: -I${base}/ipp/include\n')

	else:
		print 'Sorry, IPP %d not yet supported by this script\n' % major

	out.close()

nExecute = 0
def execute(cmd, verbose, pretend):
	global nExecute
	nExecute += 1
	if pretend:
		print '[%d] In: %s\n[%d] Pretending: %s\n' % (nExecute, getcwd(), nExecute, cmd)
	else:
		print '[%d] In: %s\n[%d] Executing: %s\n' % (nExecute, getcwd(), nExecute, cmd)
		system(cmd)

def checkDirs(comps, dir, args):
	okComps = []
	for comp in comps:
		path = dir + comp[0] + '/'
		if not isdir(path):
			if 'ok' in args:
				print 'Warning: %s does not exist.  Skipping.' % path
			else:
				print 'Error: %s does not exist.  Stopping.' % path
		else:
			okComps.append(comp)

	if not 'ok' in args and len(comps) != len(okComps):
		okComps = []

	return okComps

def checkFiles(comps, dir, fileName, args):
	okComps = []
	for comp in comps:
		file = dir + comp[0] + '/' + fileName
		if not isfile(file):
			if 'ok' in args:
				print 'Warning: %s does not exist.  Skipping.' % file
			else:
				print 'Error: %s does not exist.  Stopping.' % file
		else:
			okComps.append(comp)

	if not 'ok' in args and len(comps) != len(okComps):
		okComps = []

	return okComps

def componentList(comps):
	i = 0
	str = ''
	for c in comps:
		if i > 0:
			str += ', '
		str += c[0]
		i += 0
	return str

def filterComponentsOrig(origComps, args):
	if 'cwd' in args:
		local = split(getcwd(), '/')[-2:]
	else:
		local = []
	
	comps = []
	for c in origComps:
		if (c[0] in local or c[0] in args) and not ('noipp' in args and 'ipp' in c[2]):
			comps.append(c)
	if len(comps) == 0:
		if 'cwd' in args:
			print "Error: cannot build in local directory: don't know where I am!"
		else:
			comps = origComps

	return comps

def filterComponents(origComps, args):
	if 'all' in args:
		comps = origComps
	elif 'slave' in args:
		comps = []
		for c in origComps:
			if 'slave' in c[2]:
				comps.append(c)
	else:
		comps = []
		local = split(getcwd(), '/')[-2:]
		for c in origComps:
			if 'noipp' in args and 'ipp' in c[2]:
				continue
			if 'nopgplot' in args and 'pgplot' in c[2]:
				continue
			if c[0] in args :
				comps.append(c)
			elif c[0] in local and 'cwd' in args:
				comps.append(c)
		if len(comps) == 0:
			for c in origComps:
				if 'noipp' in args and 'ipp' in c[2]:
					continue
				if 'nopgplot' in args and 'pgplot' in c[2]:
					continue
				if c[0] in local:
					comps.append(c)
	return comps				
				


components = {}	# indexed by ${DIFX_VERSION}

# components each have the following elements:
# [
#	0 name
#	1 svn path
#	2 [build flags]
# ]

component_difxio_trunk = \
[ \
	'difxio', \
	'https://svn.atnf.csiro.au/difx/libraries/difxio/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'spice', 'slave'] \
]

component_difxmessage_trunk = \
[ \
	'difxmessage', \
	'https://svn.atnf.csiro.au/difx/libraries/difxmessage/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave'] \
]

component_mark5access_trunk = \
[ \
	'mark5access', \
	'https://svn.atnf.csiro.au/difx/libraries/mark5access/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave'] \
]

component_vdifio_trunk = \
[ \
	'vdifio', \
	'https://svn.atnf.csiro.au/difx/libraries/vdifio/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave'] \
]

component_mpifxcorr_trunk = \
[ \
	'mpifxcorr', \
	'https://svn.atnf.csiro.au/difx/mpifxcorr/trunk', \
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx', 'ipp', 'slave'] \
]

component_difx2fits_trunk = \
[ \
	'difx2fits', \
	'https://svn.atnf.csiro.au/difx/applications/difx2fits/trunk' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_difx2mark4_trunk = \
[ \
	'difx2mark4', \
	'https://svn.atnf.csiro.au/difx/applications/difx2mark4/trunk' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_vex2difx_trunk = \
[ \
	'vex2difx', \
	'https://svn.atnf.csiro.au/difx/applications/vex2difx/trunk' ,\
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]

component_mk5daemon_trunk = \
[ \
	'mk5daemon', \
	'https://svn.atnf.csiro.au/difx/applications/mk5daemon/trunk' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake', 'streamstor', 'slave'] \
]

component_calcif2_trunk = \
[ \
	'calcif2', \
	'https://svn.atnf.csiro.au/difx/utilities/trunk/calcif2' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_calcserver_trunk = \
[ \
	'calcserver', \
	'https://svn.atnf.csiro.au/difx/applications/calcserver/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'automake'] \
]

component_guiserver_trunk = \
[ \
	'guiServer', \
	'https://svn.atnf.csiro.au/difx/applications/doi/branches/USNO/guiServer', \
	['aclocal', 'autoconf', 'automake'], \
]

component_rcwlib_trunk = \
[ \
	'rcwlib', \
	'https://svn.atnf.csiro.au/difx/sites/NRAO/trunk/rcwlib', \
	['aclocal', 'libtoolize', 'autoconf', 'automake'] \
]

component_sniff_trunk = \
[ \
	'SniffPlots', \
	'https://svn.atnf.csiro.au/difx/sites/NRAO/trunk/SniffPlots', \
	['aclocal', 'autoconf', 'automake', 'pgplot'] \
]

component_hops_trunk = \
[ \
	'hops', \
	'https://svn.atnf.csiro.au/difx/applications/hops/trunk', \
	['aclocalm4', 'autoconf', 'autoheader', 'automake', 'pgplot'] \
]

components['DIFX-DEVEL'] = \
[ \
	component_difxio_trunk, \
	component_difxmessage_trunk, \
	component_mark5access_trunk, \
	component_vdifio_trunk, \
	component_mpifxcorr_trunk, \
	component_difx2fits_trunk, \
	component_difx2mark4_trunk, \
	component_vex2difx_trunk, \
	component_mk5daemon_trunk, \
	component_calcif2_trunk, \
	component_calcserver_trunk, \
	component_guiserver_trunk, \
	component_rcwlib_trunk, \
	component_sniff_trunk, \
	component_hops_trunk, \
]

component_difxio_2_1 = \
[ \
	'difxio', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/difxio', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'spice', 'slave'] \
]

component_difxmessage_2_1 = \
[ \
	'difxmessage', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/difxmessage', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave'] \
]

component_mark5access_2_1 = \
[ \
	'mark5access', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/mark5access', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave'] \
]

component_vdifio_2_1 = \
[ \
	'vdifio', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/vdifio', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave'] \
]

component_mpifxcorr_2_1 = \
[ \
	'mpifxcorr', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/mpifxcorr', \
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx', 'ipp', 'slave'] \
]

component_difx2fits_2_1 = \
[ \
	'difx2fits', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/difx2fits' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_difx2mark4_2_1 = \
[ \
	'difx2mark4', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/difx2mark4' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_vex2difx_2_1 = \
[ \
	'vex2difx', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/vex2difx' ,\
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]
component_mk5daemon_2_1 = \
[ \
	'mk5daemon', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/mk5daemon' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake', 'streamstor', 'slave'] \
]

component_calcif2_2_1 = \
[ \
	'calcif2', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/calcif2' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'], \
]

component_calcserver_2_1 = \
[ \
	'calcserver', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/calcserver', \
	['aclocal', 'libtoolize', 'autoconf', 'automake'] \
]

component_rcwlib_2_1 = \
[ \
	'rcwlib', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/sites/NRAO/rcwlib', \
	['aclocal', 'libtoolize', 'autoconf', 'automake'] \
]

component_sniff_2_1 = \
[ \
	'SniffPlots', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/sites/NRAO/SniffPlots', \
	['aclocal', 'autoconf', 'automake', 'pgplot'] \
]

component_hops_2_1 = \
[ \
	'hops', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/hops', \
	['aclocalm4', 'autoconf', 'autoheader', 'automake', 'pgplot'] \
]

components['DIFX-2.1'] = \
[ \
	component_difxio_2_1, \
	component_difxmessage_2_1, \
	component_mark5access_2_1, \
	component_vdifio_2_1, \
	component_mpifxcorr_2_1, \
	component_difx2fits_2_1, \
	component_difx2mark4_2_1, \
	component_vex2difx_2_1, \
	component_mk5daemon_2_1, \
	component_calcif2_2_1, \
	component_calcserver_2_1, \
	component_rcwlib_2_1, \
	component_sniff_2_1, \
	component_hops_2_1, \
]

# commands each have the following elements:
# [
#	0 Name
#	1 Description
#	2 Needed env variables
#	3 Command line values
#	4 Function to call
# ]

def list(comps, params, args, verbose, pretend):
	print 'Components being managed for %s are:' % environ['DIFX_VERSION']
	for c in comps:
		print '  %s' % c[0]
	print ''

def default(comps, params, args, verbose, pretend):
	execute('rm %s/bin/setup_difx' % environ['DIFX_BASE'], verbose, pretend)
	if isfile('%s/bin/setup_difx' % environ['DIFX_BASE']):
		print 'Error: could not unlink existing DiFX version'
		exit(2)
	execute('ln -s %s/setup_difx %s/bin' % (environ['DIFXROOT'], environ['DIFX_BASE']), verbose, pretend)
	if not isfile('%s/bin/setup_difx' % environ['DIFX_BASE']):
		print 'Error: could not link new DiFX version.  NO version is default now!'
		exit(2)
	writeinitfile(verbose, pretend)
	print 'New default version of DiFX selected.'
	print 'Make sure ". %s/bin/setup_difx" is in your .bashrc file' % environ['DIFX_BASE']

def splitequals(str):
	p = find(str, '=')
	if p < 0:
		return [str]
	else:
		return [strip(str[:p]), strip(str[p+1:])]

def writeinitfile(verbose, pretend):
	initfile = environ['DIFX_BASE'] + '/init.d/nrao-difx'
	print 'Writing init file: %s' % initfile
	out = open(initfile, 'w')
	out.write('#!/bin/sh\n')
	out.write('#\n')
	out.write('# Author: %s version %s\n' % (program, version))
	out.write('#\n')
	out.write('# chkconfig: 345 99 1\n')
	out.write('# description: start / stop difx daemons (mk5daemon, calserver?)\n')
	out.write('\n')
	out.write('LOCKFILE=/var/lock/subsys/`basename $0`\n')
	out.write('\n')
	out.write('# source function library\n')
	out.write('. /etc/init.d/functions\n')
	out.write('\n')
	out.write('\n')
	out.write('start() {\n')
	out.write('    if [[ `hostname -s` == %s ]]; then\n' % environ['CALC_SERVER'])
	out.write('        # set up some env vars for calcserver\n')
	out.write('        export CALC_USER=C\n')
	out.write('        export WET_ATM=Y\n')
	out.write('        export JPLEPH=%s/share/CalcServer/JPLEPH\n' % environ['DIFXROOT'])
	out.write('        export SERVERLOG=OFF\n')
	out.write('        export HORIZONS_FILENAME=%s/share/CalcServer/Horizons.lis\n' % environ['DIFXROOT'])
	out.write('        export HORIZONS_SRCNAME=TSTCURVE\n')
	out.write('        echo -n $"Starting calcserver: "\n')
	out.write('        daemon \'%s/bin/CalcServer > /dev/null &\'\n' % environ['DIFXROOT'])
	out.write('        echo\n')
	out.write('    fi\n')
	out.write('    if [[ `hostname -s` == %s ]]; then\n' % environ['DIFX_HEAD_NODE'])
	out.write('        echo -n $"Starting mk5daemon with head node capabilities: "\n')
	out.write('        daemon \'%s/bin/mk5daemon -H -e > /dev/null &\'\n' % environ['DIFXROOT'])
	out.write('    else\n')
	out.write('        echo -n $"Starting mk5daemon: "\n')
	out.write('        daemon \'%s/bin/mk5daemon -e > /dev/null &\'\n' % environ['DIFXROOT'])
	out.write('    fi\n')
	out.write('    RETVAL=$?\n')
	out.write('    echo\n')
	out.write('    [ $RETVAL = 0 ] && touch $LOCKFILE\n')
	out.write('    return $RETVAL\n')
	out.write('}\n')
	out.write('\n')
	out.write('\n')
	out.write('stop() {\n')
	out.write('    if [[ `hostname` == %s ]]; then\n' % environ['CALC_SERVER'])
	out.write('        echo -n $"Stopping calcserver: "\n')
	out.write('        killproc CalcServer\n')
	out.write('        echo\n')
	out.write('    fi\n')
	out.write('    echo -n $"Stopping mk5daemon: "\n')
	out.write('    killproc mk5daemon\n')
	out.write('    RETVAL=$?\n')
	out.write('    echo\n')
	out.write('    [ $RETVAL = 0 ] && rm -f $LOCKFILE\n')
	out.write('    return $RETVAL\n')
	out.write('}\n')
	out.write('\n')
	out.write('\n')
	out.write('case "$1" in\n')
	out.write('    start)\n')
	out.write('        start\n')
	out.write('        ;;\n')
	out.write('    stop)\n')
	out.write('        stop\n')
	out.write('        ;;\n')
	out.write('    restart)\n')
	out.write('        stop && start\n')
	out.write('        ;;\n')
	out.write('    *)\n')
	out.write('        echo $"Usage: $0 {start|stop|restart}"\n')
	out.write('        exit 1\n')
	out.write('esac\n')
	out.close()

	execute('chmod +x %s' % initfile, verbose, pretend)


def bootstrap(comps, params, args, verbose, pretend):
	setupFileName = 'setup_difx'
	requiredConfigParams = ['difxbase', 'version', 'headnode']
	if not isfile(params['ConfigFile']):
		print 'Error: bootstrapping needs the specified configuration file, %s, to exist.' % params['ConfigFile']
		return
	configData = open(params['ConfigFile'], 'r').readlines()
	config = {}
	env = []
	for c in configData:
		c = split(c, '#')[0]	# strip comments
		s = splitequals(strip(c))
		if len(s) == 2:
			t = split(s[0])
			if len(t) == 1:
				config[strip(s[0])] = strip(s[1])
			elif len(t) == 2:
				if t[0] == 'env':
					env.append([strip(t[1]), strip(s[1])])
				else:
					print 'Error: line %s is not understood' % c
					return
			else:
				print 'Error: line %s is not understood' % c
				return

	# check for required parameters:
	ok = True
	for r in requiredConfigParams:
		if not r in config.keys():
			print 'Error: config file lacks parameter %s\n' % r
			ok = False
	if not ok:
		return

	# default root
	if not 'root' in config.keys():
		config['root'] = config['difxbase'] + '/' + config['version']
	
	if verbose > 0:
		print 'Config:'
		for c in config.keys():
			print '  %s = %s' % (c, config[c])
		print 'Environment:'
		for e in env:
			print '  %s = %s' % (e[0], e[1])

#	try:
	if 1:
		setupFile = config['root'] + '/' + setupFileName
		if verbose > 0:
			print 'Writing setup file %s' % setupFile

		dirPath = '%s/directories' % config['difxbase']
		initPath = '%s/init.d' % config['difxbase']
		dirs = [config['root'], dirPath, '%s/bootstrap' % config['difxbase'], '%s/bin/' % config['difxbase'], initPath]
		for d in dirs:
			if not isdir(d):
				execute('mkdir -p %s' % d, verbose, pretend)

		# make sure dir path is world writable
		execute('chmod a+w %s' % dirPath, verbose, pretend)

		platforms = {}	# indexed by arch
		platformhostsStr = ''
		platforms[platform.machine()] = []
		for i in range(1, 10):
			if not config.has_key('altplatform%d' % i):
				break;
			aarch = config['altplatform%darch' % i]
			if not aarch in platforms:
				platforms[aarch] = []
			platforms[aarch].append([config['altplatform%d' % i], config['altplatform%dtest' % i]])
			if config.has_key('altplatform%dhost' % i):
				if i > 1:
					platformhostsStr += ','
				platformhostsStr += config['altplatform%dhost' % i]

		if config.has_key('mca'):
			print 'Making .openmpi/mca-params.conf'
			execute('mkdir -p %s/.openmpi' % environ['HOME'], verbose, pretend)
			out = open('%s/.openmpi/mca-params.conf' % environ['HOME'], 'w')
			out.write('%s\n' % config['mca'])
			out.close()

		ipproot = {}	# indexed by arch
		for a in platforms.keys():
			if config.has_key('ipproot'+a):
				ipproot[a] = config['ipproot'+a]
			elif config.has_key('ipproot'):
				ipproot[a] = config['ipproot']
			else:
				print 'Error: no ipproot set for architecture %s' % a
				ipproot = {}
				break
		if len(ipproot) == 0:
			return


		runscript = '%s/bin/runmpifxcorr.%s' % (config['difxbase'], config['version']) 
		out = open(runscript, 'w')
		out.write('#!/bin/bash\n\n')
		out.write('. %s\n' % setupFile)
		if config.has_key('wrapper'):
			out.write('%s ' % config['wrapper'])
		out.write('mpifxcorr $@\n')
		out.close()
		execute('chmod a+x %s' % runscript, verbose, pretend)
		
		out = open(setupFile, 'w')
		
		out.write('#!/bin/bash\n\n')
		out.write('export DIFX_VERSION=%s\n\n' % config['version'])
		out.write('# DiFX setup file automatically generated by difxbuild\n\n')
		out.write('DIFX_PROMPT_EXTRA=""\n')
		out.write('HWPLATFORM=`uname -m`\n')
		out.write('\n')
		out.write('export DIFX_ARCH_ROOT=%s/${HWPLATFORM}\n' % config['difxbase'])
		m = 0
		for arch in platforms.keys():
			if m > 0:
				out.write('el')
			out.write('if [[ ${HWPLATFORM} = "%s" ]]; then\n' % arch)
			out.write('  export IPPROOT=%s\n' % ipproot[arch])
			if arch in ['x86_64']:
				out.write('  export DIFXBITS=64\n')
				out.write('  export IPPARCH=intel64\n')
			elif arch in ['i386', 'i686']:
				out.write('  export DIFXBITS=32\n')
				out.write('  export IPPARCH=ia32\n')
			n = 0
			for plat in platforms[arch]:
				if n == 0:
					out.write('  if')
				else:
					out.write('  elif')
				n += 1
				out.write(' %s; then\n' % plat[1])
				out.write('    export DIFXROOT=%s-%s\n' % (config['root'], plat[0]))
				out.write('    DIFX_PROMPT_EXTRA="${DIFX_PROMPT_EXTRA} %s"\n' % plat[0])
			if arch == platform.machine():
				if n > 0:
					out.write('  else\n')
					out.write('    export DIFXROOT=%s\n' % config['root'])
					out.write('  fi\n')
				else:
					out.write('  export DIFXROOT=%s\n' % config['root'])
			else:
				out.write('  fi\n')
			m += 1
					
		out.write('fi\n')
		out.write('export DIFX_SRC=%s/src\n' % config['root'])
		out.write('export X11LIBS=-lX11\n')
		if config.has_key('calcserver'):
			calcserver = config['calcserver']
		else:
			calcserver = config['headnode']
		out.write('export CALC_SERVER=%s\n' % calcserver)
		out.write('export DIFX_HEAD_NODE=%s\n' % config['headnode'])
		out.write('export DIFX_BASE=%s\n' % config['difxbase'])
		out.write('export CFLAGS="-O2 -Wall -march=core2"\n')
		out.write('export CXXFLAGS="-O2 -Wall -march=core2"\n')
		out.write('export MPICXX=${DIFX_ARCH_ROOT}/bin/mpicxx\n')
		out.write('export PKG_CONFIG_PATH=${DIFXROOT}/lib/pkgconfig\n')
		out.write('export MARK5_DIR_PATH=${DIFX_BASE}/directories\n')
		out.write('export PGPLOT_DIR=${DIFX_ARCH_ROOT}/pgplot\n')
		out.write('export DIFX_MESSAGE_GROUP=224.2.2.1\n')
		out.write('export DIFX_MESSAGE_PORT=50200\n')
		if len(platformhostsStr) > 0:
			out.write('export PLATFORM_HOSTS=%s\n' % platformhostsStr)

		out.write('\n')
		if config.has_key('pathextra'):
			pathExtra = ':%s' % config['pathextra']
		else:
			pathExtra = ''
		out.write('export PATH=./:${DIFX_ARCH_ROOT}/bin:${DIFXROOT}/bin:${DIFX_BASE}/bin:~/bin:/bin:/usr/bin%s\n' % pathExtra)
		if config.has_key('ldextra'):
			ldExtra = ':%s' % config['ldextra']
		else:
			ldExtra = ''
		out.write('export LD_LIBRARY_PATH=${DIFX_ARCH_ROOT}/lib:/lib:/usr/lib:${DIFXROOT}/lib:${IPPROOT}/lib/${IPPARCH}:${IPPROOT}/ipp/lib/${IPPARCH}%s:${PGPLOT_DIR}\n' % ldExtra)

		for e in env:
			out.write('export %s=%s\n' % (e[0], e[1]))

		out.write("alias src='cd ${DIFX_SRC}'\n")
		out.write("alias bld='cd ${DIFXROOT}/build'\n")
		out.write('export PS1="\\u@\\h $DIFX_VERSION$DIFX_PROMPT_EXTRA \\W> "\n')

		out.write("\nif [[ ${1: -9} == difxbuild ]]; then $@; fi  # this must be the last statement in the file\n")
		out.close()

		execute('chmod +x %s' % setupFile, verbose, pretend)
		execute('cp %s %s/bin/%s.%s' % (setupFile, config['difxbase'], setupFileName, config['version']), verbose, pretend)

		execute('cp %s %s/bootstrap/"%s.%s"' % (params['ConfigFile'], config['difxbase'], split(params['ConfigFile'], '/')[-1], asctime()), verbose, pretend)

		if config.has_key('mca'):
			print '*** IMPORTANT NOTE: $HOME/.openmpi/mca-params.conf should be copied into'
			print '*** the directory $HOME/.openmpi/ of each account from which DiFX will be run\n'

		print '\nBootstrap complete.  Now source %s and continue with svn.\n' % setupFile

##	except KeyError as e:
##		print 'Parse error: ', e.errno, e.strerror


def svnupdate(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected.  Did you mean to append "all" to the command line?\n'
		return
	srcDir = environ['DIFX_SRC'] + '/'
	if not isdir(srcDir):
		execute('mkdir -p %s' % srcDir, verbose, pretend);
		
	for comp in comps:
		path = srcDir + comp[0] + '/'
		if isdir(path):
			chdir(path)
			cmd = 'svn update'
		else:
			chdir(srcDir)
			cmd = 'svn co %s %s' % (comp[1], comp[0])
		execute(cmd, verbose, pretend)

def autotool(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected.  Did you mean to append "all" to the command line?\n'
		return
	srcDir = environ['DIFX_SRC'] + '/'
	okComps = checkDirs(comps, srcDir, args)
	if verbose > 1:
		print 'Autotooling: %s' % componentList(okComps)
	for comp in okComps:
		path = srcDir + comp[0] + '/'
		chdir(path)
		buildFlags = comp[2]
		if 'aclocal' in buildFlags:
			execute('aclocal', verbose, pretend)
		if 'aclocalm4' in buildFlags:
			execute('aclocal -I m4', verbose, pretend)
		if 'libtoolize' in buildFlags:
			execute('libtoolize --copy --force', verbose, pretend)
		if 'autoconf' in buildFlags:
			execute('autoconf', verbose, pretend)
		if 'autoheader' in buildFlags:
			execute('autoheader', verbose, pretend)
		if 'automake' in buildFlags:
			execute('automake --add-missing --copy', verbose, pretend)

def build(origComps, params, args, verbose, pretend):
	if 'none' in args:
		comps = []
	else:
		comps = filterComponents(origComps, args)
		if len(comps) == 0:
			print 'No components selected.  Did you mean to append "all" to the command line?\n'
			return
	buildDir = environ['DIFXROOT'] + '/build/'
	pkgDir = environ['DIFXROOT'] + '/lib/pkgconfig/'
	srcDir = environ['DIFX_SRC'] + '/'
	okComps = checkFiles(comps, srcDir, 'configure', args)
	archRoot = environ['DIFX_BASE'] + '/' + platform.machine() + '/'
	haspgplot = isfile(archRoot + 'pgplot/libpgplot.a')	# not the most robust test...
	if len(okComps) > 0 or 'none' in args:
		if not isdir(pkgDir):
			execute('mkdir -p %s' % pkgDir, verbose, pretend)
		if not isfile(pkgDir+'/ipp.pc'):
			if not 'noipp' in args:
				if verbose > 1:
					print 'Generating ipp.pc'
				chdir(pkgDir)
				genipppc(environ['IPPROOT'])
		if verbose > 1:
			print 'Building: %s' % componentList(okComps)
		if not isdir(buildDir):
			execute('mkdir -p %s' % buildDir, verbose, pretend)
		for comp in okComps:
			srcPath = srcDir + comp[0] + '/'
			buildPath = buildDir + comp[0] + '/'
			buildFlags = comp[2]
			if 'pgplot' in buildFlags and not haspgplot:
				print 'Not building %s because pgplot was not successfully built' % comp[0]
				continue
			if not isdir(buildPath):
				execute('mkdir -p %s' % buildPath, verbose, pretend)
			chdir(buildPath)
			if not 'noconf' in args:
				configureExtras = ''
				if 'mpicxx' in buildFlags:
					configureExtras += ' CXX=${MPICXX}'
				if 'spice' in buildFlags:
					spiceRoot = archRoot + 'cspice/'
					if isfile(spiceRoot+'lib/cspice.a'):
						print 'Spice library found!'
						configureExtras += ' --with-spice-root=' + spiceRoot
					else:
						print 'Spice library %slib/cspice.a not found' % spiceRoot
						if 'strict' in args:
							print 'Bailing'
							exit(2)
						else:
							print 'Continuing anyway'	
				cmd = '%s/configure --prefix=${DIFXROOT}%s' % (srcPath, configureExtras)
				execute(cmd, verbose, pretend)
			execute('make -j %d' % numMakeCpus, verbose, pretend)
			execute('make install', verbose, pretend)
			
def rebuild(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected.  Did you mean to append "all" to the command line?\n'
		return
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	if verbose > 1:
		print 'Rebuilding: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('make -j %d' % numMakeCpus, verbose, pretend)
			execute('make install', verbose, pretend)
			
def dist(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected.  Did you mean to append "all" to the command line?\n'
		return
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	if verbose > 1:
		print 'Rebuilding: %s' % componentList(okComps)
	distDir = environ['DIFXROOT'] + '/dist/'
	if not isdir(distDir):
		execute('mkdir -p %s' % distDir, verbose, pretend)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('rm -f *.tar.gz', verbose, pretend)
			execute('make dist', verbose, pretend)
			execute('mv -f *.tar.gz %s' % distDir, verbose, pretend)

def pbuild(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected for parallel rebuild'
		return
	verb = ''
	for i in range(1, verbose):
		verb += ' -v'
	compStr = ''
	for c in comps:
		compStr += (' %s' % c[0])
	cmd = 'mpirun -host localhost,%s %s/setup_difx %s %s rebuild %s' % (environ['PLATFORM_HOSTS'], environ['DIFXROOT'], argv[0], verb, compStr)
	execute(cmd, verbose, pretend)
			
def clean(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	okComps.reverse()	# best done in reverse for reasons of dependency
	if verbose > 1:
		print 'make clean in: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			if 'distclean' in args:
				execute('make distclean', verbose, pretend)
			else:
				execute('make clean', verbose, pretend)

def pclean(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected for parallel clean'
		return
	verb = ''
	for i in range(1, verbose):
		verb += ' -v'
	compStr = ''
	for c in comps:
		compStr += (' %s' % c[0])
	cmd = 'mpirun -host localhost,%s %s/setup_difx %s %s clean %s' % (environ['PLATFORM_HOSTS'], environ['DIFXROOT'], argv[0], verb, compStr)
	execute(cmd, verbose, pretend)
			
def uninstall(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	okComps.reverse()	# best done in reverse for reasons of dependency
	if verbose > 1:
		print 'Uninstalling: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('make uninstall', verbose, pretend)

def remove(origComps, params, args, verbose, pretend):
	print 'Feature not yet implemented'

def ftpFile(url, tarDir, srcFile, args, verbose, pretend):
	wgetOptions = ''
	if 'nopassive' in args:
		wgetOptions = wgetOptions + ' --no-passive-ftp'
	else:
		print '* NOTE: if FTP hangs, try again with the nopassive argument added to the difxbuild command line'
	if not isdir(tarDir):
		execute('mkdir -p %s' % tarDir, verbose, pretend)
	if not isfile(tarDir + srcFile):
		chdir(tarDir)
		execute('wget %s %s' % (wgetOptions, url), verbose, pretend)
	else:
		print '%s file already downloaded.' % srcFile

def spice(origComps, params, args, verbose, pretend):
	arch = platform.machine()
	srcFile = 'cspice.tar.Z'
	if arch in ['x86_64']:
		spiceUrl = 'ftp://naif.jpl.nasa.gov/pub/naif/toolkit//C/PC_Linux_GCC_64bit/packages/%s' % srcFile
	elif arch in ['i386', 'i686']:
		spiceUrl = 'ftp://naif.jpl.nasa.gov/pub/naif/toolkit//C/PC_Linux_GCC_32bit/packages/%s' % srcFile
	difxBase = environ['DIFX_BASE'] + '/'
	tarDir = difxBase + 'tar/'
	# get file
	ftpFile(spiceUrl, tarDir, srcFile, args, verbose, pretend)
	# untar file
	chdir(difxBase + arch)
	execute('tar zxvf %s/%s' % (tarDir, srcFile), verbose, pretend)

def pgplot(origComps, params, args, verbose, pretend):
	arch = platform.machine()
	opsys = lower(platform.system())
	srcFile = 'pgplot%s.tar.gz' % pgplotVersion
	pgplotUrl = 'ftp://ftp.astro.caltech.edu/pub/pgplot/%s' % srcFile
	difxBase = environ['DIFX_BASE'] + '/'
	tarDir = difxBase + 'tar/'
	# get file
	ftpFile(pgplotUrl, tarDir, srcFile, args, verbose, pretend)
	# untar source
	srcDir = environ['DIFX_SRC'] + '/'
	if not isdir(srcDir):
		execute('mkdir -p %s' % srcDir, verbose, pretend)
	chdir(srcDir)
	execute('tar zxvf %s/%s' % (tarDir, srcFile), verbose, pretend)
	# make dest dir
	pgplotDir = difxBase + arch + '/pgplot'
	if not isdir(pgplotDir):
		execute('mkdir -p %s' % pgplotDir, verbose, pretend)
	chdir(pgplotDir)
	# make drivers file
	o = open('drivers.list', 'w')
	o.write('  NUDRIV 0 /NULL      Null device (no output)                           Std F77\n')
	o.write('  PNDRIV 2 /TPNG      Portable Network Graphics file - transparent background C\n')
	o.write('  PSDRIV 1 /PS        PostScript printers, monochrome, landscape        Std F77\n')
	o.write('  PSDRIV 2 /VPS       Postscript printers, monochrome, portrait         Std F77\n')
	o.write('  PSDRIV 3 /CPS       PostScript printers, color, landscape             Std F77\n')
	o.write('  PSDRIV 4 /VCPS      PostScript printers, color, portrait              Std F77\n')
	o.write('  XWDRIV 1 /XWINDOW   Workstations running X Window System              C\n')
	o.write('  XWDRIV 2 /XSERVE    Persistent window on X Window System              C\n')
	o.close()
	# generate makefile
	execute('%s/pgplot/makemake %s/pgplot %s g77_gcc' % (srcDir, srcDir, opsys), verbose, pretend)
	# modify makefile : remove bogus png.h req, optionally change g77 to gfortran, ...
	execute('mv makefile makefile.orig', verbose, pretend)
	fixpng = "-e 's/pndriv.o : .\\/png.h .\\/pngconf.h .\\/zlib.h .\\/zconf.h/pndriv.o :/'"
	fixg77 = "-e 's/=g77/=gfortran/' -e 's/-u -Wall -fPIC -O/-ffixed-form -ffixed-line-length-none -u -Wall -fPIC -O/'"
	fixg77 = ""
	execute('sed %s %s <makefile.orig >makefile' % (fixpng, fixg77), verbose, pretend)
	# make fortran and c package
	execute('make', verbose, pretend)
	execute('make cpg', verbose, pretend)
	for f in ['libpgplot.a', 'libcpgplot.a', 'libpgplot.so']:
		execute('ln -s %s/%s %s/%s/lib/%s' % (pgplotDir, f, difxBase, arch, f), verbose, pretend)


def openmpi(origComps, params, args, verbose, pretend):
	openmpiWeb = 'http://www.open-mpi.org/software/ompi/v%s/downloads' % openmpiVersion
	difxBase = environ['DIFX_BASE'] + '/'
	tarDir = difxBase + 'tar/'
	cpuDir = difxBase + platform.machine() + '/'
	cpuSrcDir = cpuDir + 'src/'
	if not isdir(tarDir):
		execute('mkdir -p %s' % tarDir, verbose, pretend)
	if not isdir(cpuSrcDir):
		execute('mkdir -p %s' % cpuSrcDir, verbose, pretend)
	openmpiFiles = popen('wget %s/md5sums.txt -O - | grep stable.tar.bz2' % openmpiWeb, 'r').readlines()
	if len(openmpiFiles) != 1:
		print "I'm confused: expecting one stable.tar.bz2 file in %s/md5sums.txt, but found %d" % (len(openmpiFiles), openmpiWeb)
		return
	goodsum = split(strip(openmpiFiles[0]))[0]
	openmpiTarFile = split(strip(openmpiFiles[0]))[1]
	download = True
	if isfile(tarDir+openmpiTarFile):
		sum = split(popen('md5sum %s%s' % (tarDir, openmpiTarFile), 'r').readline())[0]
		if sum != goodsum:
			print 'Old or corrupt file %s.  File is being moved to /tmp' % (tarDir+openmpiTarFile)
			execute('mv %s%s /tmp' % (tarDir, openmpiTarFile), verbose, pretend)
		else:
			print 'Existing file %s%s looks OK' % (tarDir, openmpiTarFile)
			download = False
	if download:
		chdir(tarDir)
		execute('wget %s/%s' % (openmpiWeb, openmpiTarFile), verbose, pretend)
		sum = split(popen('md5sum %s%s' % (tarDir, openmpiTarFile), 'r').readline())[0]
		if sum != goodsum:
			print 'Newly downloaded file %s%s does not match expected md5sum %s' % (openmpiWeb, openmpiTarFile, goodsum)
			return
	# get ompi src dir
	openmpiSrcDir = cpuSrcDir + strip(popen('tar tjf %s%s' % (tarDir, openmpiTarFile), 'r').readline())
	if isdir(openmpiSrcDir):
		print '%s already untarred in %s; assuming this is a good copy' % (openmpiTarFile, cpuSrcDir)
	else:
		chdir(cpuSrcDir)
		execute('tar jxvf %s%s' % (tarDir, openmpiTarFile), verbose, pretend)
	chdir(openmpiSrcDir)
	execute('./configure --prefix=%s --enable-heterogeneous' % cpuDir, verbose, pretend)
	execute('make -j %d' % numMakeCpus, verbose, pretend)
	execute('make install', verbose, pretend)



command_list = \
[ \
	'list', \
	'List the components managed by this script for this DiFX version', \
	[], \
	[], \
	list \
]

command_default = \
[ \
	'default', \
	'Set the default version of DiFX to that identified in the current environment and update the difx boot script', \
	['DIFXROOT', 'DIFX_BASE', 'CALC_SERVER', 'DIFX_HEAD_NODE'], \
	[], \
	default \
]

command_bootstrap = \
[ \
	'bootstrap', \
	'Begin installation process for one DiFX Version', \
	['HOME'], \
	['ConfigFile'], \
	bootstrap \
]

command_svn = \
[ \
	'svn', \
	'Checkout or update from svn repository', \
	['DIFX_SRC'], \
	[], \
	svnupdate \
]

command_autotool = \
[ \
	'autotool', \
	'Prepare source directories for configuring', \
	['DIFX_SRC'], \
	[], \
	autotool \
]

command_build = \
[ \
	'build', \
	'Run configure for each component then build/install', \
	['DIFX_SRC', 'DIFXROOT', 'MPICXX', 'PKG_CONFIG_PATH', 'DIFXBITS', 'IPPROOT', 'PGPLOT_DIR'], \
	[], \
	build \
]

command_rebuild = \
[ \
	'rebuild', \
	'Build/install each component', \
	['DIFX_SRC', 'DIFXROOT'], \
	[], \
	rebuild \
]

command_pbuild = \
[ \
	'pbuild', \
	'Parallel build/install each component on each platform', \
	['DIFX_SRC', 'DIFXROOT', 'PLATFORM_HOSTS'], \
	[], \
	pbuild \
]

command_clean = \
[ \
	'clean', \
	'Run "make clean" in each component\'s build durectory', \
	['DIFXROOT'], \
	[], \
	clean, \
]

command_dist = \
[ \
	'dist', \
	'Generate tar.gz for each component', \
	['DIFXROOT'], \
	[], \
	dist, \
]

command_pclean = \
[ \
	'pclean', \
	'Run "make clean" in each component\'s build durectory for all platforms', \
	['DIFXROOT'], \
	[], \
	pclean, \
]

command_uninstall = \
[ \
	'uninstall', \
	'Uninstall each component but leave source and build directories in tact', \
	['DIFXROOT'], \
	[], \
	uninstall \
]

command_remove = \
[ \
	'remove', \
	'Uninstall each component and remove source and build directories', \
	['DIFX_SRC', 'DIFXROOT'], \
	[], \
	remove \
]

command_spice = \
[ \
	'spice', \
	'Download (if needed) and install spice', \
	['DIFX_BASE'], \
	[], \
	spice \
]

command_pgplot = \
[ \
	'pgplot', \
	'Download (if needed), configure, compile and install pgplot version %s' % pgplotVersion, \
	['DIFX_BASE'], \
	[], \
	pgplot \
]


command_openmpi = \
[ \
	'openmpi', \
	'Download (if needed), configure, compile, and install openmpi version %s' % openmpiVersion, \
	['DIFX_BASE'], \
	[], \
	openmpi \
]

commands = \
[ \
	command_list, \
	command_bootstrap, \
	command_default, \
	command_svn, \
	command_autotool, \
	command_openmpi, \
	command_spice, \
	command_pgplot, \
	command_build, \
	command_rebuild, \
	command_pbuild, \
	command_dist, \
	command_clean, \
	command_pclean, \
	command_uninstall, \
#	command_remove, \
]


def run_command(commandName, args, verbose, pretend):
	command = None
	for c in commands:
		if c[0] == commandName:
			command = c
	if not command == None:
		hasEnviron = True
		hasParams = True
		for e in command[2]:
			if not environ.has_key(e):
				print 'Env. Var. %s needs to be set' % e
				hasEnviron = False
		nParam = len(command[3])
		params = {}
		if len(args) < nParam:
			print 'Two few arguments provided'
			hasParams = False
		else:
			for i in range(nParam):
				params[command[3][i]] = args[i]
		if hasEnviron and hasParams:
			if verbose > 1:
				print '  params=', params
				print '  extras=', args[nParam:]
				print '  pretend=', pretend
				print '  verbose=', verbose
				print ''
			print '=== Running command: %s ===\n' % command[0]
			if command[0] == 'bootstrap':
				comps = []
			else:
				comps = components[environ['DIFX_VERSION']]
			command[4](comps, params, args[nParam:], verbose, pretend)
			if pretend:
				print '\n*** PRETEND MODE WAS USED ***\n'
		else:
			print 'Not going to run.'
			
	else:
		print 'Command "%s" not recognized.  Seek help.' % commandName


def usage(prog):
	print '\n%s ver. %s  %s  %s\n' % (program, version, author, verdate)
	print 'usage:  %s [options] <command> [<command arguments>]\n' % prog
	print 'The possible commands are:\n'
	for command in commands:
		extras = ''
		for c in command[3]:
			extras = extras + ' <' + c + '>'
		print '%s%s' % (command[0], extras)
		print '  %s\n' % command[1]
	
	print '\nCurrently the following key variables are set:'
	vars = ['DIFXROOT', 'DIFX_BASE', 'DIFX_ARCH_ROOT']
	for v in vars:
		if environ.has_key(v):
			print '%s = %s' % (v, environ[v])
		else:
			print '%s is unset' % v

def main():
	try:
		opts, args = getopt.getopt(argv[1:], "hqvp", ["help", "quiet", "verbose", "pretend"])
	except getopt.GetoptError, err:
		print '%s\n' % str(err)
		usage(argv[0])
		exit(2)
	verbose = 1
	pretend = False
	for o, a in opts:
		if o == '-v':
			verbose += 1
		elif o == '-q':
			verbose -= 1
		elif o == '-h':
			usage(argv[0])
			exit(0)
		elif o == '-p':
			pretend = True

	if len(args) <= 0:
		usage(argv[0])
		exit(0)
		
	if args[0] != 'bootstrap':
		if not environ.has_key('DIFX_VERSION'):
			print 'Env. Var. DIFX_VERSION needs to be set'
			exit(2)
		if not components.has_key(environ['DIFX_VERSION']):
			print 'This script is not set up to handle version %s' % environ['DIFX_VERSION']
			exit(2)

	run_command(args[0], args[1:], verbose, pretend)

#----

if __name__ == "__main__":
	main()
