#!/usr/bin/env python

from os import environ, system, getcwd, chdir, popen, readlink
from os.path import isdir, isfile, islink, join, dirname
from sys import argv, exit, platform
import re
import getopt
from string import split, strip, find, lower
import platform
from time import asctime

program = 'difxbuild'
version = '0.20'
verdate = '20121213'
author = 'Walter Brisken <wbrisken@nrao.edu>'

difxbuildUrl = 'http://www.aoc.nrao.edu/~wbrisken/difxbuild'

openmpiVersion = '1.6'
pgplotVersion = '5.2'
numMakeCpus = 4

# TODO
# install from .tar.gz 
# generic arch install (e.g., fftw)
# option to update self
# wget option to clobber
# add gui, difx_monitor, ...
# add package dependencies and make use of them
# option to test all possible dependencies
# plplot
# python path
# svnstatus

documentation = """

             In-line documentation for difxbuild

                Nov 8, 2012  Walter Brisken

Some assumptions:

* All user directories and the difxbase paths are cross mounted and
  appear the same on all machines that will be installed with DiFX.
  Note that a DiFX installation is on a cluster, not on individual
  machines.

* The machine used for downloading has external access via the svn,
  http, and ftp protocols.

Some definitions:

* architecture: A CPU architecture.  Multiple architectures can be
  used in the same DiFX cluster.  Multiple platforms can be specified
  per architecture.  Some files are common across all versions or 
  platforms of a given architecture.  difxbuild will ensure that 
  no redundant copies are installed, simplifying cross-version and
  cross-platform maintenance.

* platform: The could be different variants of DiFX machines across
  a single cpu architecture.  For example, in the i686 architecture
  one could have multiple different Mark5 types running different 
  Conduant SDK versions, each of which needs to link to a different
  set of libraries.  difxbuild uses out-of-source-tree building so
  that all platforms for a given DiFX installation can use the same
  source tree.  Very handy for developers.

* version: The formal DiFX version (e.g., DIFX-2.1), or the development
  version (called DIFX-DEVEL).

* label: A user-defined name for the DiFX installation (to be applied
  across all platforms).  By default this is the same as the version.
  Different bootstrap files using different labels can manage multiple
  instances of a single DiFX version.  This is potentially useful if
  different DIFX-DEVEL snapshots are to be used in production.

Some useful tips for users of difxbuild:

* You can rerun bootstrap as many times as needed, changing parameters
  each time.  It may be necessary to rebuild code after a bootstrap.

* You can run "difxbuild rebuild" without any parameters if you are in
  the source component of a particular component.  Same for "build"

* After each successful (re)build/install of a component, a line of
  text is added to a file called buildlog in each platform's base
  directory.  This can be used to trace back the subversion history
  of any binary at any time.

* It is not recommended to move a difxbuild-based installation either 
  to a different machine or across machines.  Rather the new system should
  be rebootstrapped and the entire build process repeated.  If this must 
  be done, it is highly recommended to wipe out all bin/ lib/ etc/ include/
  and share/ directories under $DIFXROOT and run 'difxbuild build all'.

Bootstrap parameter options include:

* version: which version of difx to install.  Currently supported values
  are DIFX-DEVEL and DIFX-2.1.  The DIFX_VERSION environment varialbe will
  reflect this value.  This parameter is required.

* headnode: the computer that will be singled out as the head node.  The
  DIFX_HEAD_NODE environment variable will reflect this value.  This
  parameter is required.

* difxbase: the top level directory for DiFX software.  DiFX version
  independent files will be placed beneath this directory.  By default
  DiFX version specific files will be installed in a subdirectory of this
  (see information about the root parameter below).  It is
  okay (and encouraged) to use the same difxbase for all installed 
  versions.  This parameter is required.

* root: the base directory for DiFX version/label specific files for the
  primary platform.  Secondary platforms will use the same but with a
  provided extension (see altplatformX below).  If not provided, this
  parameter will default to <difxbase>/<label> .

* ipproot: path to the base of the Intel Performance Primitives library.
  This is IPP version dependent and may require a bit of trial and error
  to get right.  If this is set to  none  then an IPP-free DiFX will be
  installed.  This requires FFTW to be installed.  Each architecture
  can have its own ipproot value.  ipproot specifies the the default;
  architecture-dependent overrides are specified with a parameter such as
  ipprooti686 or ipprootx86_64.

* label: a label used to identify an installation of DiFX.  By default it
  is set equal to the specified version.  Setting it to an alternate value
  allows multiple installations of the same DiFX version to be later 
  identifyable.  The DIFX_LABEL environment variable will reflect this
  value.

* calcserver: the computer to send RPC model requests to.  If not
  specified, this will default to the value of the headnode parameter.

* cflags: default c and c++ compiler flags to use.  If not specified,
  the default of "-O2 -Wall -march=core2" will be used.

* pathextra: extra binary search paths to add the the PATH environment
  variable that is set in the setup_difx script.

* ldextra: extra paths to be added to the LD_LIBRARY_PATH environment
  variable that is set in the setup_difx script.

* wrapper: an optional wrapper program that can be used to spawn
  mpifxcorr.  This value gets coded into the runmpifxcorr.$DIFX-LABEL 
  launcher script.  For example, valgrind could be used as the 
  wrapper program if memory leek checking is desired.  Use this parameter
  with caution.

* mca: parameters to add to the .openmpi/mca-params.conf file.  If not
  provided, no such file will be created.  This can be useful to include
  or exclude certain network interfaces.

* primaryarch: Normally bootstrapping needs to be done on a machine running
  on the primary architecture.  If primaryarch is set, the bootstrapping
  step can be run on any machine.  This should be set to i686, x86_64, or
  whatever "uname -m" returns on the primary architecture.

* altplatformX: Here X is a number from 1 to 9.  This parameter gives a
  sub-label to each non-primary platform.  Examples might be SDK8 and SDK9
  for Mark5 units using two different Conduant library versions.  For each
  specified alternate platform the following three additional parameters
  are needed...

* altplatformXarch: The CPU architecture, as determined by "uname -m", 
  that this platform is based upon.

* altplatformXhost: A representative computer making use of this platform.
  This is used when spawning a parallel build process.

* altplatformXtest: A bash conditional expression used to determine if the
  computer running the setup_bash script belongs to this platform.  An 
  example is  FIXME

* env: Append extra environment variables to the setup file.  Syntax is:

env ENVVAR=VALUE

  as many env statements can be included as you want.

"""

def getippversion(path):
	if islink(path):
		path = join(dirname(path), readlink(path))
# First try ippversion.h
        ippheader = path+'/include/ippversion.h'
	if not isfile(ippheader):
		ippheader = path+'/ipp/include/ippversion.h'
		if not isfile(ippheader):
			ippheader = ''

	if (ippheader==''):
		print "Warning: ippversion.h not found, relying on IPP path ", path
		s = split(path, '/')
		possibilities = []
		for part in s:
			t = split(part, '.')
			if len(t) > 1:
				possibilities.append(part)
				if len(possibilities) < 1:
					print 'Sorry, cannot determine ipp version from path'
					exit(0)
					if len(possibilities) > 1:
						print 'Guessing version == %s' % possibilities[-1]

						return possibilities[-1]
					
	else:
		print "Reading version from ", ippheader
		major = minor = None
		for line in open(ippheader):
			m = re.search('#define\s+IPP_VERSION_STR\s+"(\S+)"', line)
			if (m != None):
				print "Got version ", m.group(1)
				return m.group(1)
			if (major == None):
			    major = re.search('#define\s+IPP_VERSION_MAJOR\s+(\S)', line)
			if (minor == None):
			    minor = re.search('#define\s+IPP_VERSION_MINOR\s+(\S)', line)
		if (major != None and minor != None):
			print "Have version ", major.group(1) + "." + minor.group(1)
			return major.group(1) + "." + minor.group(1)
		print "Sorry, cannot find IPP_VERSION_STR in ", ippheader
		exit(0)
	
# fixme: possibly should use uname to get this information
def getarch():
	bs = environ['DIFXBITS']
	if bs != None:
		return int(bs)
	else:
		print 'Warning: defaulting to 32 bit assumption'
		return 32

def genipppc(path):
	ippversion = getippversion(path)
	if ippversion == None:
		print '\nSorry: no IPP found in %s.\n\nMust quit.\n' % path
		exit(0)

	ipparch = getarch()

	major = int(split(ippversion, '.')[0])
	out = open('ipp.pc', 'w')
	out.write('base = %s\n' % path)
	out.write('\n')
	out.write('Name: ipp\n')
	out.write('Description: Intel Performance Primitives\n')
	out.write('Requires:\n')
	out.write('Version: %s\n' % ippversion)
	
	mac = False
	if platform == "darwin":
		mac = True

	if major == 6 or major == 5:
		if mac:
			libdir = 'Libraries'
		else:
			libdir = 'sharedlib'
		if ipparch == 32:
			out.write('Libs: -Wl,-rpath,${base}/%s -L${base}/%s -lipps -lguide -lippvm -lippcore\n' % (libdir, libdir))
			out.write('Cflags: -I${base}/include\n')
		else:
			out.write('Libs: -Wl,-rpath,${base}/%s -L${base}/%s -lippsem64t -lguide -lippvmem64t -lippcoreem64t\n' % (libdir, libdir))
			out.write('Cflags: -I${base}/include\n')
	elif major == 7:
		if ipparch == 32:
			libdir = 'ia32'
		else:
			libdir = 'intel64'
		out.write('Libs: -L${base}/lib/%s -L${base}/ipp/lib/%s -lipps -lippvm -lippcore -liomp5\n' % (libdir, libdir))
		out.write('Cflags: -I${base}/ipp/include\n')

	else:
		print 'Sorry, IPP %d not yet supported by this script\n' % major

	out.close()

nExecute = 0
def execute(cmd, verbose, pretend):
	global nExecute
	nExecute += 1
	if pretend:
		print '[%d] In: %s\n[%d] Pretending: %s\n' % (nExecute, getcwd(), nExecute, cmd)
		v = 0
	else:
		print '[%d] In: %s\n[%d] Executing: %s\n' % (nExecute, getcwd(), nExecute, cmd)
		v = system(cmd)
	
	return v

def checkDirs(comps, dir, args):
	okComps = []
	for comp in comps:
		path = dir + comp[0] + '/'
		if not isdir(path):
			if 'ok' in args:
				print 'Warning: %s does not exist.  Skipping.' % path
			else:
				print 'Error: %s does not exist.  Stopping.' % path
		else:
			okComps.append(comp)

	if not 'ok' in args and len(comps) != len(okComps):
		okComps = []

	return okComps

def checkFiles(comps, dir, fileName, args):
	okComps = []
	for comp in comps:
		file = dir + comp[0] + '/' + fileName
		if not isfile(file):
			if 'ok' in args:
				print 'Warning: %s does not exist.  Skipping.' % file
			else:
				print 'Error: %s does not exist.  Stopping.' % file
		else:
			okComps.append(comp)

	if not 'ok' in args and len(comps) != len(okComps):
		okComps = []

	return okComps

def componentList(comps):
	i = 0
	str = ''
	for c in comps:
		if i > 0:
			str += ', '
		str += c[0]
		i += 0
	return str

def filterComponentsOrig(origComps, args):
	if 'cwd' in args:
		local = split(getcwd(), '/')[-2:]
	else:
		local = []
	
	comps = []
	for c in origComps:
		if (c[0] in local or c[0] in args) and not ('noipp' in args and 'ipp' in c[2]):
			comps.append(c)
	if len(comps) == 0:
		if 'cwd' in args:
			print "Error: cannot build in local directory: don't know where I am!"
		else:
			comps = origComps

	return comps

def filterComponents(origComps, args):
	if 'all' in args:
		comps = origComps
	elif 'core' in args:
		comps = []
		for c in origComps:
			if 'core' in c[2]:
				comps.append(c)
	elif 'slave' in args:
		comps = []
		for c in origComps:
			if 'slave' in c[2]:
				comps.append(c)
	else:
		comps = []
		local = split(getcwd(), '/')[-2:]
		for c in origComps:
			if 'noipp' in args and 'ipp' in c[2]:
				continue
			if 'nopgplot' in args and 'pgplot' in c[2]:
				continue
			if c[0] in args :
				comps.append(c)
			elif c[0] in local and 'cwd' in args:
				comps.append(c)
		if len(comps) == 0:
			for c in origComps:
				if 'noipp' in args and 'ipp' in c[2]:
					continue
				if 'nopgplot' in args and 'pgplot' in c[2]:
					continue
				if c[0] in local:
					comps.append(c)
	return comps				
				


components = {}	# indexed by ${DIFX_VERSION}

# components each have the following elements:
# [
#	0 name
#	1 svn path
#	2 [build flags]
#	FIXME: add dependencies
# ]

component_difxio_trunk = \
[ \
	'difxio', \
	'https://svn.atnf.csiro.au/difx/libraries/difxio/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'spice', 'slave'] \
]

component_difxmessage_trunk = \
[ \
	'difxmessage', \
	'https://svn.atnf.csiro.au/difx/libraries/difxmessage/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave', 'core'] \
]

component_mark5access_trunk = \
[ \
	'mark5access', \
	'https://svn.atnf.csiro.au/difx/libraries/mark5access/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave', 'core'] \
]

component_vdifio_trunk = \
[ \
	'vdifio', \
	'https://svn.atnf.csiro.au/difx/libraries/vdifio/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave', 'core'] \
]

component_mpifxcorr_trunk = \
[ \
	'mpifxcorr', \
	'https://svn.atnf.csiro.au/difx/mpifxcorr/trunk', \
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx', 'ipp', 'slave', 'core'] \
]

component_difx2fits_trunk = \
[ \
	'difx2fits', \
	'https://svn.atnf.csiro.au/difx/applications/difx2fits/trunk' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_difx2mark4_trunk = \
[ \
	'difx2mark4', \
	'https://svn.atnf.csiro.au/difx/applications/difx2mark4/trunk' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_vex2difx_trunk = \
[ \
	'vex2difx', \
	'https://svn.atnf.csiro.au/difx/applications/vex2difx/trunk' ,\
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]

component_mk5daemon_trunk = \
[ \
	'mk5daemon', \
	'https://svn.atnf.csiro.au/difx/applications/mk5daemon/trunk' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake', 'streamstor', 'slave', 'core'] \
]

component_calcif2_trunk = \
[ \
	'calcif2', \
	'https://svn.atnf.csiro.au/difx/utilities/trunk/calcif2' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_calcserver_trunk = \
[ \
	'calcserver', \
	'https://svn.atnf.csiro.au/difx/applications/calcserver/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'automake'] \
]

component_guiserver_trunk = \
[ \
	'guiServer', \
	'https://svn.atnf.csiro.au/difx/applications/gui/trunk/guiServer', \
	['aclocal', 'autoconf', 'automake'], \
]

component_rcwlib_trunk = \
[ \
	'rcwlib', \
	'https://svn.atnf.csiro.au/difx/sites/NRAO/trunk/rcwlib', \
	['aclocal', 'libtoolize', 'autoconf', 'automake'] \
]

component_sniff_trunk = \
[ \
	'SniffPlots', \
	'https://svn.atnf.csiro.au/difx/sites/NRAO/trunk/SniffPlots', \
	['aclocal', 'autoconf', 'automake', 'pgplot'] \
]

component_hops_trunk = \
[ \
	'hops', \
	'https://svn.atnf.csiro.au/difx/applications/hops/trunk', \
	['aclocalm4', 'autoconf', 'autoheader', 'automake', 'pgplot'] \
]

component_python_trunk = \
[ \
	'python', \
	'https://svn.atnf.csiro.au/difx/libraries/python/trunk', \
	['aclocal', 'autoconf', 'automake'] \
]

component_misc_utils_trunk = \
[ \
	'misc_utils', \
	'https://svn.atnf.csiro.au/difx/utilities/trunk/misc', \
	['aclocal', 'autoconf', 'automake'] \
]

component_vis2screen_trunk = \
[ \
	'vis2screen', \
	'https://svn.atnf.csiro.au/difx/utilities/trunk/vis2screen', \
	['aclocal', 'autoconf', 'automake', 'mpicxx'] \
]

component_difx2profile_trunk = \
[ \
	'difx2profile', \
	'https://svn.atnf.csiro.au/difx/utilities/trunk/pulsar/difx2profile', \
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx'] \
]

component_vdifserver_trunk = \
[ \
	'vdif_server', \
	'https://svn.atnf.csiro.au/difx/applications/vdif_server/trunk',
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx'] \
]

component_difxdb_trunk = \
[ \
	'difxdb', \
	'https://svn.atnf.csiro.au/difx/libraries/python/trunk', \
	['aclocal', 'autoconf', 'automake'] \
]

component_difxmonitor_trunk = \
[ \
	'difx_monitor', \
	'https://svn.atnf.csiro.au/difx/applications/difx_monitor/trunk', \
	['aclocal', 'autoconf', 'automake', 'mpicxx'] \
]

component_difxfilterbank_trunk = \
[ \
	'difxfilterbank', \
	'https://svn.atnf.csiro.au/difx/applications/difxfilterbank/trunk', \
	['aclocal', 'autoconf', 'automake', 'mpicxx'] \
]

components['DIFX-DEVEL'] = \
[ \
	component_difxio_trunk, \
	component_difxmessage_trunk, \
	component_mark5access_trunk, \
	component_vdifio_trunk, \
	component_mpifxcorr_trunk, \
	component_difx2fits_trunk, \
	component_difx2mark4_trunk, \
	component_vex2difx_trunk, \
	component_mk5daemon_trunk, \
	component_calcif2_trunk, \
	component_calcserver_trunk, \
	component_guiserver_trunk, \
	component_rcwlib_trunk, \
	component_sniff_trunk, \
	component_hops_trunk, \
	component_python_trunk, \
	component_misc_utils_trunk, \
	component_vis2screen_trunk, \
	component_difx2profile_trunk, \
	component_vdifserver_trunk, \
	component_difxdb_trunk, \
	component_difxfilterbank_trunk, \
	component_difxmonitor_trunk, \
]

component_difxio_2_1 = \
[ \
	'difxio', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/difxio', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'spice', 'slave'] \
]

component_difxmessage_2_1 = \
[ \
	'difxmessage', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/difxmessage', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave', 'core'] \
]

component_mark5access_2_1 = \
[ \
	'mark5access', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/mark5access', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave', 'core'] \
]

component_vdifio_2_1 = \
[ \
	'vdifio', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/vdifio', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'slave', 'core'] \
]

component_mpifxcorr_2_1 = \
[ \
	'mpifxcorr', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/mpifxcorr', \
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx', 'ipp', 'slave', 'core'] \
]

component_difx2fits_2_1 = \
[ \
	'difx2fits', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/difx2fits' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_difx2mark4_2_1 = \
[ \
	'difx2mark4', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/difx2mark4' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_vex2difx_2_1 = \
[ \
	'vex2difx', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/vex2difx' ,\
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]
component_mk5daemon_2_1 = \
[ \
	'mk5daemon', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/mk5daemon' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake', 'streamstor', 'slave', 'core'] \
]

component_calcif2_2_1 = \
[ \
	'calcif2', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/calcif2' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'], \
]

component_calcserver_2_1 = \
[ \
	'calcserver', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/calcserver', \
	['aclocal', 'libtoolize', 'autoconf', 'automake'] \
]

component_rcwlib_2_1 = \
[ \
	'rcwlib', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/sites/NRAO/rcwlib', \
	['aclocal', 'libtoolize', 'autoconf', 'automake'] \
]

component_sniff_2_1 = \
[ \
	'SniffPlots', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/sites/NRAO/SniffPlots', \
	['aclocal', 'autoconf', 'automake', 'pgplot'] \
]

component_hops_2_1 = \
[ \
	'hops', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/hops', \
	['aclocalm4', 'autoconf', 'autoheader', 'automake', 'pgplot'] \
]

components['DIFX-2.1'] = \
[ \
	component_difxio_2_1, \
	component_difxmessage_2_1, \
	component_mark5access_2_1, \
	component_vdifio_2_1, \
	component_mpifxcorr_2_1, \
	component_difx2fits_2_1, \
	component_difx2mark4_2_1, \
	component_vex2difx_2_1, \
	component_mk5daemon_2_1, \
	component_calcif2_2_1, \
	component_calcserver_2_1, \
	component_rcwlib_2_1, \
	component_sniff_2_1, \
	component_hops_2_1, \
]

# commands each have the following elements:
# [
#	0 Name
#	1 Description
#	2 Needed env variables
#	3 Command line values
#	4 Function to call
# ]

def list(comps, params, args, verbose, pretend):
	print 'Components being managed for %s are:' % environ['DIFX_VERSION']
	for c in comps:
		print '  %s' % c[0]
	print ''

def default(comps, params, args, verbose, pretend):
	execute('rm %s/bin/setup_difx' % environ['DIFX_BASE'], verbose, pretend)
	if isfile('%s/bin/setup_difx' % environ['DIFX_BASE']):
		print 'Error: could not unlink existing DiFX version'
		exit(2)
	execute('ln -s %s/setup_difx %s/bin' % (environ['DIFXROOT'], environ['DIFX_BASE']), verbose, pretend)
	if not isfile('%s/bin/setup_difx' % environ['DIFX_BASE']):
		print 'Error: could not link new DiFX version.  NO version is default now!'
		exit(2)
	writeinitfile(verbose, pretend)
	print 'New default version of DiFX selected.'
	print 'Make sure ". %s/bin/setup_difx" is in your .bashrc file' % environ['DIFX_BASE']

def splitequals(str):
	p = find(str, '=')
	if p < 0:
		return [str]
	else:
		return [strip(str[:p]), strip(str[p+1:])]

def writeinitfile(verbose, pretend):
	initfile = environ['DIFX_BASE'] + '/init.d/nrao-difx'
	print 'Writing init file: %s' % initfile
	out = open(initfile, 'w')
	out.write('#!/bin/sh\n')
	out.write('#\n')
	out.write('# Author: %s version %s\n' % (program, version))
	out.write('#\n')
	out.write('# chkconfig: 345 99 1\n')
	out.write('# description: start / stop difx daemons (mk5daemon, calserver?)\n')
	out.write('\n')
	out.write('LOCKFILE=/var/lock/subsys/`basename $0`\n')
	out.write('\n')
	out.write('# source function library\n')
	out.write('. /etc/init.d/functions\n')
	out.write('\n')
	out.write('\n')
	out.write('start() {\n')
	out.write('    if [[ `hostname -s` == %s ]]; then\n' % environ['CALC_SERVER'])
	out.write('        # set up some env vars for calcserver\n')
	out.write('        export CALC_USER=C\n')
	out.write('        export WET_ATM=Y\n')
	out.write('        export JPLEPH=%s/share/CalcServer/JPLEPH\n' % environ['DIFXROOT'])
	out.write('        export SERVERLOG=OFF\n')
	out.write('        export HORIZONS_FILENAME=%s/share/CalcServer/Horizons.lis\n' % environ['DIFXROOT'])
	out.write('        export HORIZONS_SRCNAME=TSTCURVE\n')
	out.write('        echo -n $"Starting calcserver: "\n')
	out.write('        daemon \'%s/bin/CalcServer > /dev/null &\'\n' % environ['DIFXROOT'])
	out.write('        echo\n')
	out.write('    fi\n')
	out.write('    if [[ `hostname -s` == %s ]]; then\n' % environ['DIFX_HEAD_NODE'])
	out.write('        echo -n $"Starting mk5daemon with head node capabilities: "\n')
	out.write('        daemon \'%s/bin/mk5daemon -H -e > /dev/null &\'\n' % environ['DIFXROOT'])
	out.write('    else\n')
	out.write('        echo -n $"Starting mk5daemon: "\n')
	out.write('        daemon \'%s/bin/mk5daemon -e > /dev/null &\'\n' % environ['DIFXROOT'])
	out.write('    fi\n')
	out.write('    RETVAL=$?\n')
	out.write('    echo\n')
	out.write('    [ $RETVAL = 0 ] && touch $LOCKFILE\n')
	out.write('    return $RETVAL\n')
	out.write('}\n')
	out.write('\n')
	out.write('\n')
	out.write('stop() {\n')
	out.write('    if [[ `hostname` == %s ]]; then\n' % environ['CALC_SERVER'])
	out.write('        echo -n $"Stopping calcserver: "\n')
	out.write('        killproc CalcServer\n')
	out.write('        echo\n')
	out.write('    fi\n')
	out.write('    echo -n $"Stopping mk5daemon: "\n')
	out.write('    killproc mk5daemon\n')
	out.write('    RETVAL=$?\n')
	out.write('    echo\n')
	out.write('    [ $RETVAL = 0 ] && rm -f $LOCKFILE\n')
	out.write('    return $RETVAL\n')
	out.write('}\n')
	out.write('\n')
	out.write('\n')
	out.write('case "$1" in\n')
	out.write('    start)\n')
	out.write('        start\n')
	out.write('        ;;\n')
	out.write('    stop)\n')
	out.write('        stop\n')
	out.write('        ;;\n')
	out.write('    restart)\n')
	out.write('        stop && start\n')
	out.write('        ;;\n')
	out.write('    *)\n')
	out.write('        echo $"Usage: $0 {start|stop|restart}"\n')
	out.write('        exit 1\n')
	out.write('esac\n')
	out.close()

	execute('chmod +x %s' % initfile, verbose, pretend)


def bootstrap(comps, params, args, verbose, pretend):
	setupFileName = 'setup_difx'
	requiredConfigParams = ['difxbase', 'version', 'headnode']
	if not isfile(params['ConfigFile']):
		print 'Error: bootstrapping needs the specified configuration file, %s, to exist.' % params['ConfigFile']
		return
		
	configData = open(params['ConfigFile'], 'r').readlines()
	config = {}
	env = []
	for c in configData:
		c = split(c, '#')[0]	# strip comments
		s = splitequals(strip(c))
		if len(s) == 2:
			t = split(s[0])
			if len(t) == 1:
				config[strip(s[0])] = strip(s[1])
			elif len(t) == 2:
				if t[0] == 'env':
					env.append([strip(t[1]), strip(s[1])])
				else:
					print 'Error: line %s is not understood' % c
					return
			else:
				print 'Error: line %s is not understood' % c
				return

	# check for required parameters:
	ok = True
	for r in requiredConfigParams:
		if not r in config.keys():
			print 'Error: config file lacks parameter %s\n' % r
			ok = False
	if not ok:
		return

	if config['version'] not in components.keys():
		print 'Error: version must be one of ', components.keys()
		return
	
	if config.has_key('label'):
		label = config['label']
	else:
		label = config['version']

	# default root
	if not 'root' in config.keys():
		config['root'] = config['difxbase'] + '/' + label
	
	if verbose > 0:
		print 'Config:'
		for c in config.keys():
			print '  %s = %s' % (c, config[c])
		print 'Environment:'
		for e in env:
			print '  %s = %s' % (e[0], e[1])

	if 1:
		setupFile = config['root'] + '/' + setupFileName
		if verbose > 0:
			print 'Writing setup file %s' % setupFile

		dirPath = '%s/directories' % config['difxbase']
		initPath = '%s/init.d' % config['difxbase']
		dirs = [config['root'], dirPath, '%s/bootstrap' % config['difxbase'], '%s/bin/' % config['difxbase'], initPath]
		for d in dirs:
			if not isdir(d):
				execute('mkdir -p %s' % d, verbose, pretend)

		# make sure dir path is world writable
		execute('chmod a+w %s' % dirPath, verbose, pretend)

		platforms = {}	# indexed by arch
		platformhostsStr = ''
		
		# make entry for primary architecture, which is assumed to be the one where bootstrapping is done
		# unless overridden by primaryarch parameter
		if config.has_key('primaryarch'):
			primaryarch = config['primaryarch']
		else:
			primaryarch = platform.machine()
		platforms[primaryarch] = []
		
		for i in range(1, 10):
			if not config.has_key('altplatform%d' % i):
				break
			for suffix in ['host', 'arch', 'test']:
				if not config.has_key('altplatform%d%s' % (i, suffix)):
					print 'Error: altplatform%d%s is not set.' % (i, suffix)
					exit(0)
			aarch = config['altplatform%darch' % i]
			if not aarch in platforms:
				platforms[aarch] = []
			platforms[aarch].append([config['altplatform%d' % i], config['altplatform%dtest' % i]])
			if config.has_key('altplatform%dhost' % i):
				if i > 1:
					platformhostsStr += ','
				platformhostsStr += config['altplatform%dhost' % i]

		if config.has_key('mca'):
			print 'Making .openmpi/mca-params.conf'
			execute('mkdir -p %s/.openmpi' % environ['HOME'], verbose, pretend)
			out = open('%s/.openmpi/mca-params.conf' % environ['HOME'], 'w')
			mca = split(config['mca'], ';')
			for m in mca:
				out.write('%s\n' % m)
			out.close()

		ipproot = {}	# indexed by arch
		for a in platforms.keys():
			if config.has_key('ipproot'+a):
				ipproot[a] = config['ipproot'+a]
			elif config.has_key('ipproot'):
				ipproot[a] = config['ipproot']
			else:
				print 'Error: no ipproot set for architecture %s' % a
				ipproot = {}
				break
		if len(ipproot) == 0:
			return

		runscript = '%s/bin/runmpifxcorr.%s' % (config['difxbase'], label) 
		out = open(runscript, 'w')
		out.write('#!/bin/bash\n\n')
		out.write('. %s\n' % setupFile)
		if config.has_key('wrapper'):
			out.write('%s ' % config['wrapper'])
		out.write('mpifxcorr $@\n')
		out.close()
		execute('chmod a+x %s' % runscript, verbose, pretend)
		
		out = open(setupFile, 'w')
		
		out.write('#!/bin/bash\n\n')
		out.write('export DIFX_VERSION=%s\n\n' % config['version'])
		out.write('export DIFX_LABEL=%s\n\n' % label)
		out.write('# DiFX setup file automatically generated by difxbuild\n\n')
		out.write('DIFX_PROMPT_EXTRA=""\n')
		out.write('HWPLATFORM=`uname -m`\n')
		out.write('\n')
		out.write('export DIFX_ARCH_ROOT=%s/${HWPLATFORM}\n' % config['difxbase'])
		m = 0
		for arch in platforms.keys():
			if ipproot[arch] == 'none':
				ipproot[arch] = ''

			if m > 0:
				out.write('el')
			out.write('if [[ ${HWPLATFORM} = "%s" ]]; then\n' % arch)
			out.write('  export IPPROOT=%s\n' % ipproot[arch])
			if arch in ['x86_64']:
				out.write('  export DIFXBITS=64\n')
				out.write('  export IPPARCH=intel64\n')
			elif arch in ['i386', 'i686']:
				out.write('  export DIFXBITS=32\n')
				out.write('  export IPPARCH=ia32\n')
			n = 0
			for plat in platforms[arch]:
				if n == 0:
					out.write('  if')
				else:
					out.write('  elif')
				n += 1
				out.write(' %s; then\n' % plat[1])
				out.write('    export DIFXROOT=%s-%s\n' % (config['root'], plat[0]))
				out.write('    DIFX_PROMPT_EXTRA="${DIFX_PROMPT_EXTRA} %s"\n' % plat[0])
			if arch == primaryarch:
				if n > 0:
					out.write('  else\n')
					out.write('    export DIFXROOT=%s\n' % config['root'])
					out.write('  fi\n')
				else:
					out.write('  export DIFXROOT=%s\n' % config['root'])
			else:
				out.write('  fi\n')
			m += 1
					
		out.write('fi\n')
		out.write('export DIFX_SRC=%s/src\n' % config['root'])
		out.write('export X11LIBS=-lX11\n')
		if config.has_key('calcserver'):
			calcserver = config['calcserver']
		else:
			calcserver = config['headnode']
		out.write('export CALC_SERVER=%s\n' % calcserver)
		out.write('export DIFX_HEAD_NODE=%s\n' % config['headnode'])
		out.write('export DIFX_BASE=%s\n' % config['difxbase'])
		if config.has_key('cflags'):
			cflags = config['cflags']
		else:
			cflags = '-O2 -Wall -march=core2'
		out.write('export CFLAGS="%s"\n' % cflags)
		out.write('export CXXFLAGS="%s"\n' % cflags)
		out.write('export MPICXX=${DIFX_ARCH_ROOT}/bin/mpicxx\n')
		out.write('export PKG_CONFIG_PATH=${DIFXROOT}/lib/pkgconfig:${DIFX_ARCH_ROOT}/lib/pkgconfig\n')
		out.write('export MARK5_DIR_PATH=${DIFX_BASE}/directories\n')
		out.write('export PGPLOT_DIR=${DIFX_ARCH_ROOT}/pgplot\n')
		out.write('export DIFX_MESSAGE_GROUP=224.2.2.1\n')
		out.write('export DIFX_MESSAGE_PORT=50200\n')
		if len(platformhostsStr) > 0:
			out.write('export PLATFORM_HOSTS=%s\n' % platformhostsStr)

		out.write('\n')
		if config.has_key('pathextra'):
			pathExtra = ':%s' % config['pathextra']
		else:
			pathExtra = ''
		out.write('export PATH=./:${DIFX_ARCH_ROOT}/bin:${DIFXROOT}/bin:${DIFX_BASE}/bin:~/bin:/bin:/usr/bin%s\n' % pathExtra)
		if config.has_key('ldextra'):
			ldExtra = ':%s' % config['ldextra']
		else:
			ldExtra = ''
		out.write('export LD_LIBRARY_PATH=${DIFX_ARCH_ROOT}/lib:/lib:/usr/lib:${DIFXROOT}/lib:${IPPROOT}/lib/${IPPARCH}:${IPPROOT}/ipp/lib/${IPPARCH}%s:${PGPLOT_DIR}\n' % ldExtra)

		for e in env:
			out.write('export %s=%s\n' % (e[0], e[1]))

		out.write("alias src='cd ${DIFX_SRC}'\n")
		out.write("alias bld='cd ${DIFXROOT}/build'\n")
		out.write('export PS1="\\u@\\h %s$DIFX_PROMPT_EXTRA \\W> "\n' % label)

		out.write("\nif [[ ${1: -9} == difxbuild ]]; then $@; fi  # this must be the last statement in the file\n")
		out.close()

		execute('chmod +x %s' % setupFile, verbose, pretend)
		execute('rm -f %s/bin/%s.%s' % (config['difxbase'], setupFileName, label), verbose, pretend)
		execute('ln -s %s %s/bin/%s.%s' % (setupFile, config['difxbase'], setupFileName, label), verbose, pretend)


		# copy bootstrap file for future reference
		execute('cp %s %s/bootstrap/"%s.%s.%s"' % (params['ConfigFile'], config['difxbase'], split(params['ConfigFile'], '/')[-1], asctime(), version), verbose, pretend)
		# copy setup file for future reference
		execute('cp %s %s/bootstrap/"%s.%s.%s"' % (setupFile, config['difxbase'], split(setupFile, '/')[-1], asctime(), version), verbose, pretend)

		if config.has_key('mca'):
			print '*** IMPORTANT NOTE: $HOME/.openmpi/mca-params.conf should be copied into'
			print '*** the directory $HOME/.openmpi/ of each account from which DiFX will be run\n'

		print '\nBootstrap complete.  Now source %s and continue with svn.\n' % setupFile


def svnupdate(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected.  Did you mean to append "all" to the command line?\n'
		return
	srcDir = environ['DIFX_SRC'] + '/'
	if not isdir(srcDir):
		execute('mkdir -p %s' % srcDir, verbose, pretend);

	updatePaths = ''

	badRepositories = []

	for comp in comps:
		path = srcDir + comp[0] + '/'
		if isdir(path):
			updatePaths = updatePaths + ' ' + comp[0]
			url = split(strip(popen('svn info %s | grep URL' % path, 'r').readlines()[0]))[-1]

			if url != comp[1]:
				badRepositories.append('%s %s' % (comp[0], path))
		else:
			chdir(srcDir)
			cmd = 'svn co %s %s' % (comp[1], comp[0])
			execute(cmd, verbose, pretend)
	
	if len(badRepositories) > 0:
		print 'Error: the following components\' svn URLS don\'t match:'
		for b in badRepositories:
			print '  %s' % b
		print 'Please remove these directories and try again taking care to preserve any local changes you may have made'
	elif updatePaths != '':
		chdir(srcDir)
		cmd = 'svn update ' + updatePaths
		execute(cmd, verbose, pretend)


def svnstatus(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected.  Did you mean to append "all" to the command line?\n'
		return
	srcDir = environ['DIFX_SRC'] + '/'
	if not isdir(srcDir):
		print 'Top level source directory %s does not exist.\n' % srcDir
		
	for comp in comps:
		path = srcDir + comp[0] + '/'
		if isdir(path):
			chdir(path)
			cmd = 'svn status -q'
			execute(cmd, verbose, pretend)

def autotool(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected.  Did you mean to append "all" to the command line?\n'
		return
	srcDir = environ['DIFX_SRC'] + '/'
	okComps = checkDirs(comps, srcDir, args)
	if verbose > 1:
		print 'Autotooling: %s' % componentList(okComps)
	for comp in okComps:
		path = srcDir + comp[0] + '/'
		chdir(path)
		buildFlags = comp[2]
		if 'aclocal' in buildFlags:
			execute('aclocal', verbose, pretend)
		if 'aclocalm4' in buildFlags:
			execute('aclocal -I m4', verbose, pretend)
		if 'libtoolize' in buildFlags:
			execute('libtoolize --copy --force', verbose, pretend)
		if 'autoconf' in buildFlags:
			execute('autoconf', verbose, pretend)
		if 'autoheader' in buildFlags:
			execute('autoheader', verbose, pretend)
		if 'automake' in buildFlags:
			execute('automake --add-missing --copy', verbose, pretend)

def build(origComps, params, args, verbose, pretend):
	if 'none' in args:
		comps = []
	else:
		comps = filterComponents(origComps, args)
		if len(comps) == 0:
			print 'No components selected.  Did you mean to append "all" to the command line?\n'
			return
	buildDir = environ['DIFXROOT'] + '/build/'
	pkgDir = environ['DIFXROOT'] + '/lib/pkgconfig/'
	bldLog = environ['DIFXROOT'] + '/buildlog'
	srcDir = environ['DIFX_SRC'] + '/'
	okComps = checkFiles(comps, srcDir, 'configure', args)
	archRoot = environ['DIFX_BASE'] + '/' + platform.machine() + '/'
	haspgplot = isfile(archRoot + 'pgplot/libpgplot.a')	# not the most robust test...
	if len(okComps) > 0 or 'none' in args:
		if not isdir(pkgDir):
			execute('mkdir -p %s' % pkgDir, verbose, pretend)
		if not isfile(pkgDir+'/ipp.pc') and len(environ['IPPROOT']) > 0:
			if not 'noipp' in args:
				if verbose > 1:
					print 'Generating ipp.pc'
				chdir(pkgDir)
				genipppc(environ['IPPROOT'])
		if verbose > 1:
			print 'Building: %s' % componentList(okComps)
		if not isdir(buildDir):
			execute('mkdir -p %s' % buildDir, verbose, pretend)
		for comp in okComps:
			srcPath = srcDir + comp[0] + '/'
			buildPath = buildDir + comp[0] + '/'
			buildFlags = comp[2]
			if 'pgplot' in buildFlags and not haspgplot:
				print 'Not building %s because pgplot was not successfully built' % comp[0]
				continue
			if not isdir(buildPath):
				execute('mkdir -p %s' % buildPath, verbose, pretend)
			chdir(buildPath)
			if not 'noconf' in args:
				configureExtras = ''
				if 'mpicxx' in buildFlags:
					configureExtras += ' CXX=${MPICXX}'
				if 'spice' in buildFlags:
					spiceRoot = archRoot + 'cspice/'
					if isfile(spiceRoot+'lib/cspice.a'):
						print 'Spice library found!'
						configureExtras += ' --with-spice-root=' + spiceRoot
					else:
						print 'Spice library %slib/cspice.a not found' % spiceRoot
						if 'strict' in args:
							print 'Bailing'
							exit(2)
						else:
							print 'Continuing anyway'	
				cmd = '%s/configure --prefix=${DIFXROOT}%s' % (srcPath, configureExtras)
				execute(cmd, verbose, pretend)
			
			# building mpifxcorr sometimes fails if done in parallel
			if comp[0] == 'mpifxcorr':
				cpus = 1
			else:
				cpus = numMakeCpus
			
			v = execute('make -j %d' % cpus, verbose, pretend)
			if v == 0:
				v = execute('make install', verbose, pretend)
			if v != 0:
				print '\n*** Error building %s ***\n' % comp[0]
				return 
			chdir(srcDir+comp[0])
			execute('echo `date`  $DIFX_VERSION  $DIFX_LABEL  %s  BUILD  `svn info | grep "Changed Rev"` >> %s' % (comp[0], bldLog), verbose, pretend)
			
def rebuild(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected.  Did you mean to append "all" to the command line?\n'
		return
	buildDir = environ['DIFXROOT'] + '/build/'
	srcDir = environ['DIFX_SRC'] + '/'
	bldLog = environ['DIFXROOT'] + '/buildlog'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	if verbose > 1:
		print 'Rebuilding: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)

			# building mpifxcorr sometimes fails if done in parallel
			if comp[0] == 'mpifxcorr':
				cpus = 1
			else:
				cpus = numMakeCpus
			
			v = execute('make -j %d' % cpus, verbose, pretend)
			if v == 0:
				v = execute('make install', verbose, pretend)
			if v != 0:
				print '\n*** Error rebuilding %s ***\n' % comp[0]
				return
			chdir(srcDir+comp[0])
			execute('echo `date`  $DIFX_VERSION  $DIFX_LABEL  %s  REBUILD  `svn info | grep "Changed Rev"` >> %s' % (comp[0], bldLog), verbose, pretend)
			
def dist(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected.  Did you mean to append "all" to the command line?\n'
		return
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	if verbose > 1:
		print 'Rebuilding: %s' % componentList(okComps)
	distDir = environ['DIFXROOT'] + '/dist/'
	if not isdir(distDir):
		execute('mkdir -p %s' % distDir, verbose, pretend)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('rm -f *.tar.gz', verbose, pretend)
			v = execute('make dist', verbose, pretend)
			if v != 0:
				print '\n*** make dist error for %s ***\n' % comp[0]
				return
			execute('mv -f *.tar.gz %s' % distDir, verbose, pretend)

def pbuild(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected for parallel rebuild'
		return
	verb = ''
	for i in range(1, verbose):
		verb += ' -v'
	compStr = ''
	for c in comps:
		compStr += (' %s' % c[0])
	cmd = 'mpirun -host localhost,%s %s/setup_difx %s %s rebuild %s' % (environ['PLATFORM_HOSTS'], environ['DIFXROOT'], argv[0], verb, compStr)
	execute(cmd, verbose, pretend)
			
def clean(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	okComps.reverse()	# best done in reverse for reasons of dependency
	if verbose > 1:
		print 'make clean in: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			if 'distclean' in args:
				execute('make distclean', verbose, pretend)
			else:
				execute('make clean', verbose, pretend)

def pclean(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	if len(comps) == 0:
		print 'No components selected for parallel clean'
		return
	verb = ''
	for i in range(1, verbose):
		verb += ' -v'
	compStr = ''
	for c in comps:
		compStr += (' %s' % c[0])
	cmd = 'mpirun -host localhost,%s %s/setup_difx %s %s clean %s' % (environ['PLATFORM_HOSTS'], environ['DIFXROOT'], argv[0], verb, compStr)
	execute(cmd, verbose, pretend)
			
def uninstall(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	okComps.reverse()	# best done in reverse for reasons of dependency
	if verbose > 1:
		print 'Uninstalling: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('make uninstall', verbose, pretend)

def remove(origComps, params, args, verbose, pretend):
	print 'Feature not yet implemented'

def ftpFile(url, tarDir, srcFile, args, verbose, pretend):
	wgetOptions = ''
	if 'nopassive' in args:
		wgetOptions = wgetOptions + ' --no-passive-ftp'
	else:
		print '* NOTE: if FTP hangs, try again with the nopassive argument added to the difxbuild command line'
	if not isdir(tarDir):
		execute('mkdir -p %s' % tarDir, verbose, pretend)
	if not isfile(tarDir + srcFile):
		chdir(tarDir)
		execute('wget %s %s' % (wgetOptions, url), verbose, pretend)
	else:
		print '%s file already downloaded.' % srcFile

def spice(origComps, params, args, verbose, pretend):
	arch = platform.machine()
	srcFile = 'cspice.tar.Z'
	if arch in ['x86_64']:
		spiceUrl = 'ftp://naif.jpl.nasa.gov/pub/naif/toolkit//C/PC_Linux_GCC_64bit/packages/%s' % srcFile
	elif arch in ['i386', 'i686']:
		spiceUrl = 'ftp://naif.jpl.nasa.gov/pub/naif/toolkit//C/PC_Linux_GCC_32bit/packages/%s' % srcFile
	difxBase = environ['DIFX_BASE'] + '/'
	tarDir = difxBase + 'tar/'
	archDir = difxBase + arch
	# get file
	ftpFile(spiceUrl, tarDir, srcFile, args, verbose, pretend)
	# untar file
	if not isdir(archDir):
		execute('mkdir -p %s' % archDir, verbose, pretend)
	chdir(archDir)
	execute('tar zxvf %s/%s' % (tarDir, srcFile), verbose, pretend)

def pgplot(origComps, params, args, verbose, pretend):
	arch = platform.machine()
	opsys = lower(platform.system())
	srcFile = 'pgplot%s.tar.gz' % pgplotVersion
	pgplotUrl = 'ftp://ftp.astro.caltech.edu/pub/pgplot/%s' % srcFile
	difxBase = environ['DIFX_BASE'] + '/'
	tarDir = difxBase + 'tar/'
	# get file
	ftpFile(pgplotUrl, tarDir, srcFile, args, verbose, pretend)
	# untar source
	srcDir = environ['DIFX_SRC'] + '/'
	if not isdir(srcDir):
		execute('mkdir -p %s' % srcDir, verbose, pretend)
	chdir(srcDir)
	execute('tar zxvf %s/%s' % (tarDir, srcFile), verbose, pretend)
	# make dest dir
	pgplotDir = difxBase + arch + '/pgplot'
	if not isdir(pgplotDir):
		execute('mkdir -p %s' % pgplotDir, verbose, pretend)
	chdir(pgplotDir)
	# make drivers file
	o = open('drivers.list', 'w')
	o.write('  NUDRIV 0 /NULL      Null device (no output)                           Std F77\n')
	o.write('  PNDRIV 2 /TPNG      Portable Network Graphics file - transparent background C\n')
	o.write('  PSDRIV 1 /PS        PostScript printers, monochrome, landscape        Std F77\n')
	o.write('  PSDRIV 2 /VPS       Postscript printers, monochrome, portrait         Std F77\n')
	o.write('  PSDRIV 3 /CPS       PostScript printers, color, landscape             Std F77\n')
	o.write('  PSDRIV 4 /VCPS      PostScript printers, color, portrait              Std F77\n')
	o.write('  XWDRIV 1 /XWINDOW   Workstations running X Window System              C\n')
	o.write('  XWDRIV 2 /XSERVE    Persistent window on X Window System              C\n')
	o.close()
	# generate makefile
	execute('%s/pgplot/makemake %s/pgplot %s g77_gcc' % (srcDir, srcDir, opsys), verbose, pretend)
	# modify makefile : remove bogus png.h req, optionally change g77 to gfortran, ...
	execute('mv makefile makefile.orig', verbose, pretend)
	fixpng = "-e 's/pndriv.o : .\\/png.h .\\/pngconf.h .\\/zlib.h .\\/zconf.h/pndriv.o :/'"
	if len(popen('which gfortran').readlines()) > 0:
		fixg77 = "-e 's/=g77/=gfortran/' -e 's/-u -Wall -fPIC -O/-ffixed-form -ffixed-line-length-none -u -Wall -fPIC -O/'"
	else:
		fixg77 = ""
	execute('sed %s %s <makefile.orig >makefile' % (fixpng, fixg77), verbose, pretend)
	# make fortran and c package
	v = execute('make', verbose, pretend)
	if v == 0:
		execute('make cpg', verbose, pretend)
	if v != 0:
		print '\n*** Error building pgplot ***\n'
		return 
	linkDir = '%s/%s/lib' % (difxBase, arch)
	if not isdir(linkDir):
		execute('mkdir -p %s' % linkDir, verbose, pretend)
	for f in ['libpgplot.a', 'libcpgplot.a', 'libpgplot.so']:
		execute('rm -f %s/%s' % (linkDir, f), verbose, pretend)
		execute('cp %s/%s %s/%s' % (pgplotDir, f, linkDir, f), verbose, pretend)

def newestOMPI(data, version):
	filename = 'openmpi-%s.tar.bz2' % version
	md5 = ''
	release = 0
	m = re.compile('openmpi-%s.([0-9]+).tar.bz2' % version)
	for q in data:
		d = strip(split(q)[-1])
		if d == filename:
			md5 = split(q)[0]
		else:
			v = m.search(d)
			if v != None:
				r = int(v.group(1))
				if r > release:
					release = r
					filename = 'openmpi-%s.%d.tar.bz2' % (version, release)
					md5 = split(q)[0]

	return filename, md5

def openmpi(origComps, params, args, verbose, pretend):
	difxBase = environ['DIFX_BASE'] + '/'
	bldLog = environ['DIFXROOT'] + '/buildlog'
	tarDir = difxBase + 'tar/'
	cpuDir = difxBase + platform.machine() + '/'
	cpuSrcDir = cpuDir + 'src/'
	if not isdir(tarDir):
		execute('mkdir -p %s' % tarDir, verbose, pretend)
	if not isdir(cpuSrcDir):
		execute('mkdir -p %s' % cpuSrcDir, verbose, pretend)

	if len(args) > 0:
		if not isfile(args[0]):
			print 'Error: %s is not a file!' % args[0]
			exit(2)
		execute('cp -n %s %s' % (args[0], tarDir), verbose, pretend)
		openmpiTarFile = split(args[0], '/')[-1]
	else:
		openmpiWeb = 'http://www.open-mpi.org/software/ompi/v%s/downloads' % openmpiVersion
		openmpiFiles = popen('wget %s/md5sums.txt -O -' % openmpiWeb, 'r').readlines()
		if len(openmpiFiles) < 1:
			print "I'm confused: cannot find openmpi source files from %s" % openmpiWeb
			return
		goodsum = split(strip(openmpiFiles[0]))[0]
		openmpiTarFile = split(strip(openmpiFiles[0]))[1]
		openmpiTarFile, goodsum = newestOMPI(openmpiFiles, openmpiVersion)
		download = True
		if isfile(tarDir+openmpiTarFile):
			sum = split(popen('md5sum %s%s' % (tarDir, openmpiTarFile), 'r').readline())[0]
			if sum != goodsum:
				print 'Old or corrupt file %s.  File is being moved to /tmp' % (tarDir+openmpiTarFile)
				execute('mv %s%s /tmp' % (tarDir, openmpiTarFile), verbose, pretend)
			else:
				print 'Existing file %s%s looks OK' % (tarDir, openmpiTarFile)
				download = False
		if download:
			chdir(tarDir)
			execute('wget %s/%s' % (openmpiWeb, openmpiTarFile), verbose, pretend)
			sum = split(popen('md5sum %s%s' % (tarDir, openmpiTarFile), 'r').readline())[0]
			if sum != goodsum:
				print 'Newly downloaded file %s%s does not match expected md5sum %s' % (openmpiWeb, openmpiTarFile, goodsum)
				return
	
	srcFileExt = split(openmpiTarFile, '.')[-1]
	if srcFileExt == 'bz2':
		td = 'j'
	elif srcFileExt == 'gz':
		td = 'z'
	else:
		td = ''

	openmpiSrcDir = cpuSrcDir + strip(popen('tar t%sf %s%s' % (td, tarDir, openmpiTarFile), 'r').readline())
	if isdir(openmpiSrcDir):
		print '%s already untarred in %s; assuming this is a good copy' % (openmpiTarFile, cpuSrcDir)
	else:
		chdir(cpuSrcDir)
		execute('tar %sxvf %s%s' % (td, tarDir, openmpiTarFile), verbose, pretend)
	chdir(openmpiSrcDir)
	execute('./configure --prefix=%s --enable-heterogeneous' % cpuDir, verbose, pretend)
	v = execute('make -j %d' % numMakeCpus, verbose, pretend)
	if v == 0:
		v = execute('make install', verbose, pretend)
		execute('echo `date`  $DIFX_VERSION  $DIFX_LABEL  OpenMPI %s >> %s' % (openmpiTarFile, bldLog), verbose, pretend)
	if v != 0:
		print '\n*** Error building openmpi***\n'
		return 

def update_difxbuild(origComps, params, args, verbose, pretend):
	dir = getcwd()
	chdir('/tmp')
	execute('rm -f difxbuild', verbose, pretend)
	execute('wget %s' % difxbuildUrl, verbose, pretend)
	print 'Current version = %s' % version
	newVersion = strip(popen('python /tmp/difxbuild --version', 'r').readlines()[0])
	print 'New version = %s' % newVersion
	print 
	if newVersion <= version:
		print 'difxbuild up to date; not need to update'
	else:
		execute('chmod +x /tmp/difxbuild', verbose, pretend)
		chdir(dir)
		if find(argv[0], '/') >= 0:
			execute('cp /tmp/difxbuild %s' % argv[0], verbose, pretend)
		else:
			execute('cp /tmp/difxbuild `which difxbuild`', verbose, pretend)

		print 'difxbuild updated.  Please confirm with --version'


command_list = \
[ \
	'list', \
	'List the components managed by this script for this DiFX version', \
	[], \
	[], \
	list \
]

command_default = \
[ \
	'default', \
	'Set the default version of DiFX to that identified in the current environment and update the difx boot script', \
	['DIFXROOT', 'DIFX_BASE', 'CALC_SERVER', 'DIFX_HEAD_NODE'], \
	[], \
	default \
]

command_bootstrap = \
[ \
	'bootstrap', \
	'Begin installation process for one DiFX Version', \
	['HOME'], \
	['ConfigFile'], \
	bootstrap \
]

command_svn = \
[ \
	'svn', \
	'Checkout or update from svn repository', \
	['DIFX_SRC'], \
	[], \
	svnupdate \
]

command_svnstatus = \
[ \
	'svnstatus', \
	'View local svn changes', \
	['DIFX_SRC'], \
	[], \
	svnstatus \
]

command_autotool = \
[ \
	'autotool', \
	'Prepare source directories for configuring', \
	['DIFX_SRC'], \
	[], \
	autotool \
]

command_build = \
[ \
	'build', \
	'Run configure for each component then build/install', \
	['DIFX_SRC', 'DIFXROOT', 'MPICXX', 'PKG_CONFIG_PATH', 'DIFXBITS', 'IPPROOT', 'PGPLOT_DIR'], \
	[], \
	build \
]

command_rebuild = \
[ \
	'rebuild', \
	'Build/install each component', \
	['DIFX_SRC', 'DIFXROOT'], \
	[], \
	rebuild \
]

command_pbuild = \
[ \
	'pbuild', \
	'Parallel build/install each component on each platform', \
	['DIFX_SRC', 'DIFXROOT', 'PLATFORM_HOSTS'], \
	[], \
	pbuild \
]

command_clean = \
[ \
	'clean', \
	'Run "make clean" in each component\'s build durectory', \
	['DIFXROOT'], \
	[], \
	clean, \
]

command_dist = \
[ \
	'dist', \
	'Generate tar.gz for each component', \
	['DIFXROOT'], \
	[], \
	dist, \
]

command_pclean = \
[ \
	'pclean', \
	'Run "make clean" in each component\'s build durectory for all platforms', \
	['DIFXROOT'], \
	[], \
	pclean, \
]

command_uninstall = \
[ \
	'uninstall', \
	'Uninstall each component but leave source and build directories in tact', \
	['DIFXROOT'], \
	[], \
	uninstall \
]

command_remove = \
[ \
	'remove', \
	'Uninstall each component and remove source and build directories', \
	['DIFX_SRC', 'DIFXROOT'], \
	[], \
	remove \
]

command_spice = \
[ \
	'spice', \
	'Download (if needed) and install spice', \
	['DIFX_BASE'], \
	[], \
	spice \
]

command_pgplot = \
[ \
	'pgplot', \
	'Download (if needed), configure, compile and install pgplot version %s' % pgplotVersion, \
	['DIFX_BASE'], \
	[], \
	pgplot \
]

command_openmpi = \
[ \
	'openmpi', \
	'Download (if needed), configure, compile, and install openmpi version %s' % openmpiVersion, \
	['DIFX_BASE'], \
	[], \
	openmpi \
]

command_update = \
[ \
	'update', \
	'Update difxbuild by downloading a new version', \
	[], \
	[], \
	update_difxbuild \
]

commands = \
[ \
	command_list, \
	command_bootstrap, \
	command_default, \
	command_svn, \
	command_svnstatus, \
	command_autotool, \
	command_openmpi, \
	command_spice, \
	command_pgplot, \
	command_build, \
	command_rebuild, \
	command_pbuild, \
	command_dist, \
	command_clean, \
	command_pclean, \
	command_uninstall, \
	command_update, \
#	command_remove, \
]


def run_command(commandName, args, verbose, pretend):
	command = None
	for c in commands:
		if c[0] == commandName:
			command = c
	if not command == None:
		hasEnviron = True
		hasParams = True
		for e in command[2]:
			if not environ.has_key(e):
				print 'Env. Var. %s needs to be set' % e
				hasEnviron = False
		nParam = len(command[3])
		params = {}
		if len(args) < nParam:
			print 'Two few arguments provided'
			hasParams = False
		else:
			for i in range(nParam):
				params[command[3][i]] = args[i]
		if hasEnviron and hasParams:
			if verbose > 1:
				print '  params=', params
				print '  extras=', args[nParam:]
				print '  pretend=', pretend
				print '  verbose=', verbose
				print ''
			print '=== Running command: %s ===\n' % command[0]
			if command[0] == 'bootstrap':
				comps = []
			else:
				comps = components[environ['DIFX_VERSION']]
			command[4](comps, params, args[nParam:], verbose, pretend)
			if pretend:
				print '\n*** PRETEND MODE WAS USED ***\n'
		else:
			print 'Not going to run.'
			
	else:
		print 'Command "%s" not recognized.  Seek help.' % commandName


def usage(prog):
	print '\n%s ver. %s  %s  %s\n' % (program, version, author, verdate)
	print 'usage:  %s [options] <command> [<command arguments>]\n' % prog
	print 'Options include:\n'
	print '  -h or --help'
	print '       print this help and exit\n'
	print '  -d or --documentation'
	print '       print the in-line documentation\n'
	print '  -v or --verbose'
	print '       be more verbose\n'
	print '  -V or --version'
	print '       print version and exit\n'
	print '  -q or --quiet'
	print '       be less verbose\n'
	print '  -p or --pretend'
	print '       go through all the steps but don\'t actually do anything\n'
	print 'The possible commands are:\n'
	for command in commands:
		extras = ''
		for c in command[3]:
			extras = extras + ' <' + c + '>'
		print '%s%s' % (command[0], extras)
		print '  %s\n' % command[1]
	
	print '\nCurrently the following key variables are set:'
	vars = ['DIFXROOT', 'DIFX_BASE', 'DIFX_ARCH_ROOT']
	for v in vars:
		if environ.has_key(v):
			print '%s = %s' % (v, environ[v])
		else:
			print '%s is unset' % v

def main():
	try:
		opts, args = getopt.getopt(argv[1:], "hdqvpV", ["help", "documentation", "quiet", "verbose", "pretend", "version"])
	except getopt.GetoptError, err:
		print '%s\n' % str(err)
		usage(argv[0])
		exit(2)
	verbose = 1
	pretend = False
	for o, a in opts:
		if o == '-v':
			verbose += 1
		elif o == '--version':
			print version
			exit(0)
		elif o == '-q':
			verbose -= 1
		elif o == '-h':
			usage(argv[0])
			exit(0)
		elif o == '-d':
			print documentation
			exit(0)
		elif o == '-p':
			pretend = True

	if len(args) <= 0:
		usage(argv[0])
		exit(0)
		
	if args[0] != 'bootstrap':
		if not environ.has_key('DIFX_VERSION'):
			print 'Env. Var. DIFX_VERSION needs to be set'
			exit(2)
		if not components.has_key(environ['DIFX_VERSION']):
			print 'This script is not set up to handle version %s' % environ['DIFX_VERSION']
			exit(2)

	run_command(args[0], args[1:], verbose, pretend)

#----

if __name__ == "__main__":
	main()
