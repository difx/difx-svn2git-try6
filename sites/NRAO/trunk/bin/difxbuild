#!/bin/env python

from os import environ, system, getcwd, chdir, popen
from os.path import isdir, isfile
from sys import argv, exit
import getopt
from string import split, strip
from platform import machine

openmpiVersion = "1.6"
numMakeCpus = 4

def execute(cmd, verbose, pretend):
	if pretend:
		print '%s# %s' % (getcwd(), cmd)
	else:
		if verbose:
			print 'In: %s   Executing: %s' % (getcwd(), cmd)
		system(cmd)
def checkDirs(comps, dir, args):
	okComps = []
	for comp in comps:
		path = dir + comp[0] + '/'
		if not isdir(path):
			if 'ok' in args:
				print 'Warning: %s does not exist.  Skipping.' % path
			else:
				print 'Error: %s does not exist.  Stopping.' % path
		else:
			okComps.append(comp)

	if not 'ok' in args and len(comps) != len(okComps):
		okComps = []

	return okComps

def checkFiles(comps, dir, fileName, args):
	okComps = []
	for comp in comps:
		file = dir + comp[0] + '/' + fileName
		if not isfile(file):
			if 'ok' in args:
				print 'Warning: %s does not exist.  Skipping.' % file
			else:
				print 'Error: %s does not exist.  Stopping.' % file
		else:
			okComps.append(comp)

	if not 'ok' in args and len(comps) != len(okComps):
		okComps = []

	return okComps

def componentList(comps):
	i = 0
	str = ''
	for c in comps:
		if i > 0:
			str += ', '
		str += c[0]
		i += 0
	return str

def filterComponents(origComps, args):
	if 'cwd' in args:
		local = split(getcwd(), '/')[-2:]
	else:
		local = []
	
	comps = []
	for c in origComps:
		if c[0] in local or c[0] in args:
			comps.append(c)
	if len(comps) == 0:
		if 'cwd' in args:
			print "Error: cannot build in local directory: don't know where I am!"
		else:
			comps = origComps
	return comps

components = {}	# indexed by ${DIFX_VERSION}

# components each have the following elements:
# [
#	0 name
#	1 svn path
#	2 [build flags]
# ]

component_difxio_trunk = \
[ \
	'difxio', \
	'https://svn.atnf.csiro.au/difx/libraries/difxio/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_difxmessage_trunk = \
[ \
	'difxmessage', \
	'https://svn.atnf.csiro.au/difx/libraries/difxmessage/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_mark5access_trunk = \
[ \
	'mark5access', \
	'https://svn.atnf.csiro.au/difx/libraries/mark5access/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_vdifio_trunk = \
[ \
	'vdifio', \
	'https://svn.atnf.csiro.au/difx/libraries/vdifio/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_mpifxcorr_trunk = \
[ \
	'mpifxcorr', \
	'https://svn.atnf.csiro.au/difx/mpifxcorr/trunk', \
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx', 'ipp'] \
]

component_difx2fits_trunk = \
[ \
	'difx2fits', \
	'https://svn.atnf.csiro.au/difx/applications/difx2fits/trunk' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'], \
]

component_vex2difx_trunk = \
[ \
	'vex2difx', \
	'https://svn.atnf.csiro.au/difx/applications/vex2difx/trunk' ,\
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_calcif2_trunk = \
[ \
	'calcif2', \
	'https://svn.atnf.csiro.au/difx/utilities/trunk/calcif2' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'], \
]

components['DIFX-DEVEL'] = \
[ \
	component_difxio_trunk, \
	component_difxmessage_trunk, \
	component_mark5access_trunk, \
	component_vdifio_trunk, \
	component_mpifxcorr_trunk, \
	component_difx2fits_trunk, \
	component_vex2difx_trunk, \
	component_calcif2_trunk, \
]

component_difxio_2_1 = \
[ \
	'difxio', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/difxio', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_difxmessage_2_1 = \
[ \
	'difxmessage', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/difxmessage', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_mark5access_2_1 = \
[ \
	'mark5access', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/mark5access', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_vdifio_2_1 = \
[ \
	'vdifio', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/vdifio', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_mpifxcorr_2_1 = \
[ \
	'mpifxcorr', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/mpifxcorr', \
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx', 'ipp'] \
]

component_difx2fits_2_1 = \
[ \
	'difx2fits', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/difx2fits' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'], \
]

component_vex2difx_2_1 = \
[ \
	'vex2difx', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/vex2difx' ,\
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_calcif2_2_1 = \
[ \
	'calcif2', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/calcif2' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'], \
]

components['DIFX-2.1'] = \
[ \
	component_difxio_2_1, \
	component_difxmessage_2_1, \
	component_mark5access_2_1, \
	component_vdifio_2_1, \
	component_mpifxcorr_2_1, \
	component_difx2fits_2_1, \
	component_vex2difx_2_1, \
	component_calcif2_2_1, \
]

# commands each have the following elements:
# [
#	0 Name
#	1 Description
#	2 Needed env variables
#	3 Command line values
#	4 Function to call
# ]

def list(comps, params, args, verbose, pretend):
	print 'Components being managed for %s are:' % environ['DIFX_VERSION']
	for c in comps:
		print '  %s' % c[0]
	print ''

def bootstrap(comps, params, args, verbose, pretend):
	if not isfile(params['ConfigFile']):
		print 'Error: bootstrapping needs the specified configuration file, %s, to exist.' % params['ConfigFile']
		return
	configData = open(params['ConfigFile'], 'r').readlines()
	config = {}
	env = {}
	for c in configData:
		c = split(c, '#')[0]	# strip comments
		s = split(strip(c), '=')
		if len(s) == 2:
			t = split(s[0])
			if len(t) == 1:
				config[strip(s[0])] = strip(s[1])
			elif len(t) == 2:
				if t[0] == 'env':
					env[strip(t[1])] = strip(s[1])
				else:
					print 'Error: line %s is not understood' % c
					return
			else:
				print 'Error: line %s is not understood' % c
				return
	
	if verbose > 0:
		print 'Config:'
		for c in config.keys():
			print '  %s = %s' % (c, config[c])
		print 'Environment:'
		for e in env.keys():
			print '  %s = %s' % (e, env[e])

	try:
		setupFile = config['root'] + '/setup_difx'
		if verbose > 0:
			print 'Writing setup file %s' % setupFile

		dirs = [config['root'], '%s/directories' % config['difxbase'], '~/bin/']
		for d in dirs:
			if not isdir(d):
				execute('mkdir -p %s' % d, verbose, pretend)

		platforms = {}
		platforms[machine()] = []
		for i in range(1, 10):
			if not config.has_key('altplatform%d' % i):
				break;
			aarch = config['altplatform%darch' % i]
			if not aarch in platforms:
				platforms[aarch] = []
			platforms[aarch].append([config['altplatform%d' % i], config['altplatform%dtest' % i]])
		
		out = open(setupFile, 'w')
		
		out.write('#!/bin/bash\n\n')
		out.write('# DiFX setup file automatically generated by difxbuild\n\n')
		out.write('DIFX_PROMPT_EXTRA=""\n')
		out.write('HWPLATFORM=`uname --processor`\n')
		out.write('\n')
		out.write('export DIFX_ARCH_ROOT=%s/${HWPLATFORM}\n' % config['root'])
		for arch in platforms.keys():
			out.write('if [[ ${HWPLATFORM} = "%s" ]]; then\n' % arch)
			if arch in ['x86_64']:
				out.write('  export DIFXBITS=64\n')
				out.write('  export IPPARCH=intel64\n')
			elif arch in ['i386', 'i686']:
				out.write('  export DIFXBITS=32\n')
				out.write('  export IPPARCH=ia32\n')
			n = 0
			for plat in platforms[arch]:
				if n == 0:
					out.write('  if')
				else:
					out.write('  elif')
				n += 1
				out.write(' %s; then\n' % plat[1])
				out.write('    export DIFXROOT=%s-%s\n' % (config['root'], plat[0]))
				out.write('    DIFX_PROMPT_EXTRA="${DIFX_PROMPT_EXTRA} %s"\n' % plat[0])
			if arch == machine():
				if n > 0:
					out.write('  else\n')
					out.write('    export DIFXROOT=%s\n' % config['root'])
					out.write('  fi\n')
				else:
					out.write('  export DIFXROOT=%s\n' % config['root'])
			else:
				out.write('  fi\n')
					
			out.write('fi\n')
		out.write('export DIFX_SRC=%s/src\n' % config['root'])
		out.write('export IPPROOT=%s\n' % config['ipproot'])
		out.write('export X11LIBS=-lX11\n')
		out.write('export CALC_SERVER=%s\n' % config['calcserver'])
		out.write('export DIFX_HEAD_NODE=%s\n' % config['headnode'])
		out.write('export DIFX_BASE=%s\n' % config['difxbase'])
		if not env.has_key('CFLAGS'):
			out.write('export CFLAGS="-O2 -Wall -march=core2"\n')
		if not env.has_key('CXXFLAGS'):
			out.write('export CXXFLAGS="-O2 -Wall -march=core2"\n')
		out.write('export MPICXX=${DIFX_ARCH_ROOT}/bin/mpicxx')
		out.write('export PKG_CONFIG_PATH=${DIFXROOT}/lib/pkgconfig\n')
		out.write('export MARK5_DIR_PATH=${DIFX_BASE}/directories\n')
		if not env.has_key('DIFX_MESSAGE_GROUP'):
			out.write('export DIFX_MESSAGE_GROUP=224.2.2.1')
		if not env.has_key('DIFX_MESSAGE_PORT'):
			out.write('export DIFX_MESSAGE_PORT=50200')

		out.write('\n')
		out.write('export PATH=${DIFX_ARCH_ROOT}/bin:${DIFXROOT}/bin:~/bin:/bin:/usr/bin\n')
		out.write('export LD_LIBRARY_PATH=${DIFX_ARCH_ROOT}/lib:/lib:/usr/lib:${DIFXROOT}/lib:${IPPROOT}/${IPPARCH}/ipp/lib/${IPPARCH}:${IPPROOT}/${IPPARCH}/lib/${IPPARCH}\n')

		for e in env.keys():
			out.write('export %s=%s\n' % (e, env[e]))

		out.write("alias src='cd ${DIFX_SRC}'\n")
		out.write("alias bld='cd ${DIFX_PREFIX}/build'\n")

		out.close()

	except KeyError:
		print 'Parse error'


def svnupdate(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	srcDir = environ['DIFX_SRC'] + '/'
	if not isdir(srcDir):
		execute('mkdir -p %s' % srcDir, verbose, pretend);
		
	for comp in comps:
		path = srcDir + comp[0] + '/'
		if isdir(path):
			chdir(path)
			cmd = 'svn update'
		else:
			chdir(srcDir)
			cmd = 'svn co %s %s' % (comp[1], comp[0])
		execute(cmd, verbose, pretend)

def autotool(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	srcDir = environ['DIFX_SRC'] + '/'
	okComps = checkDirs(comps, srcDir, args)
	if verbose > 1:
		print 'Autotooling: %s' % componentList(okComps)
	for comp in okComps:
		path = srcDir + comp[0] + '/'
		chdir(path)
		buildFlags = comp[2]
		if 'aclocal' in buildFlags:
			execute('aclocal', verbose, pretend)
		if 'libtoolize' in buildFlags:
			execute('libtoolize --copy --force', verbose, pretend)
		if 'autoconf' in buildFlags:
			execute('autoconf', verbose, pretend)
		if 'autoheader' in buildFlags:
			execute('autoheader', verbose, pretend)
		if 'automake' in buildFlags:
			execute('automake -a', verbose, pretend)

def build(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	srcDir = environ['DIFX_SRC'] + '/'
	okComps = checkFiles(comps, srcDir, 'configure', args)
	if len(okComps) > 0:
		if verbose > 1:
			print 'Building: %s' % componentList(okComps)
		if not isdir(buildDir):
			execute('mkdir -p %s' % buildDir, verbose, pretend)
		for comp in okComps:
			srcPath = srcDir + comp[0] + '/'
			buildPath = buildDir + comp[0] + '/'
			if not isdir(buildPath):
				execute('mkdir -p %s' % buildPath, verbose, pretend)
			chdir(buildPath)
			if not 'noconf' in args:
				buildFlags = comp[2]
				configureExtras = ''
				if 'mpicxx' in buildFlags:
					configureExtras += ' CXX=${MPICXX}'
				cmd = '%s/configure --prefix=${DIFXROOT}%s' % (srcPath, configureExtras)
				execute(cmd, verbose, pretend)
			execute('make -j %d' % numMakeCpus, verbose, pretend)
			execute('make install', verbose, pretend)
			
def rebuild(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	if verbose > 1:
		print 'Rebuilding: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('make -j %d' % numMakeCpus, verbose, pretend)
			execute('make install', verbose, pretend)
			
def uninstall(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	okComps.reverse()	# best done in reverse for reasons of dependency
	if verbose > 1:
		print 'Uninstalling: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('make uninstall', verbose, pretend)

def remove(origComps, params, args, verbose, pretend):
	print 'Feature not yet implemented'

def openmpi(origComps, params, args, verbose, pretend):
	openmpiWeb = 'http://www.open-mpi.org/software/ompi/v%s/downloads' % openmpiVersion
	difxBase = environ['DIFX_BASE'] + '/'
	tarDir = difxBase + 'tar/'
	cpuDir = difxBase + machine() + '/'
	cpuSrcDir = cpuDir + 'src/'
	if not isdir(tarDir):
		execute('mkdir -p %s' % tarDir, verbose, pretend)
	if not isdir(cpuSrcDir):
		execute('mkdir -p %s' % cpuSrcDir, verbose, pretend)
	openmpiFiles = popen('wget %s/md5sums.txt -O - | grep stable.tar.bz2' % openmpiWeb, 'r').readlines()
	if len(openmpiFiles) != 1:
		print "I'm confused: expecting one stable.tar.bz2 file in %s/md5sums.txt, but found %d" % (len(openmpiFiles), openmpiWeb)
		return
	goodsum = split(strip(openmpiFiles[0]))[0]
	openmpiTarFile = split(strip(openmpiFiles[0]))[1]
	download = True
	if isfile(tarDir+openmpiTarFile):
		sum = split(popen('md5sum %s%s' % (tarDir, openmpiTarFile), 'r').readline())[0]
		if sum != goodsum:
			print 'Old or corrupt file %s.  File is being moved to /tmp' % (tarDir+openmpiTarFile)
			execute('mv %s%s /tmp' % (tarDir, openmpiTarFile), verbose, pretend)
		else:
			print 'Existing file %s%s looks OK' % (tarDir, openmpiTarFile)
			download = False
	if download:
		chdir(tarDir)
		execute('wget %s/%s' % (openmpiWeb, openmpiTarFile), verbose, pretend)
		sum = split(popen('md5sum %s%s' % (tarDir, openmpiTarFile), 'r').readline())[0]
		if sum != goodsum:
			print 'Newly downloaded file %s%s does not match expected md5sum %s' % (openmpiWeb, openmpiTarFile, goodsum)
			return
	# get ompi src dir
	openmpiSrcDir = cpuSrcDir + strip(popen('tar tjf %s%s' % (tarDir, openmpiTarFile), 'r').readline())
	if isdir(openmpiSrcDir):
		print '%s already untarred in %s; assuming this is a good copy' % (openmpiTarFile, cpuSrcDir)
	else:
		chdir(cpuSrcDir)
		execute('tar jxvf %s%s' % (tarDir, openmpiTarFile), verbose, pretend)
	chdir(openmpiSrcDir)
	execute('./configure --prefix=%s --enable-heterogeneous' % cpuDir, verbose, pretend)
	execute('make -j %d' % numMakeCpus, verbose, pretend)
	execute('make install', verbose, pretend)



command_list = \
[ \
	'list', \
	'List the components managed by this script for this DiFX version', \
	[], \
	[], \
	list \
]

command_bootstrap = \
[ \
	'bootstrap', \
	'Begin installation process for one DiFX Version', \
	[], \
	['ConfigFile'], \
	bootstrap \
]

command_svn = \
[ \
	'svn', \
	'Checkout or update from svn repository', \
	['DIFX_SRC'], \
	[], \
	svnupdate \
]

command_autotool = \
[ \
	'autotool', \
	'Prepare source directory for configuring', \
	['DIFX_SRC'], \
	[], \
	autotool \
]

command_build = \
[ \
	'build', \
	'Run configure for each component then build/install', \
	['DIFX_SRC', 'DIFXROOT', 'MPICXX', 'PKG_CONFIG_PATH'], \
	[], \
	build \
]

command_rebuild = \
[ \
	'rebuild', \
	'Build/install each component', \
	['DIFX_SRC', 'DIFXROOT'], \
	[], \
	rebuild \
]

command_uninstall = \
[ \
	'uninstall', \
	'Uninstall each component but leave source and build directories in tact', \
	['DIFXROOT'], \
	[], \
	uninstall \
]

command_remove = \
[ \
	'remove', \
	'Uninstall each component and remove source and build directories', \
	['DIFX_SRC', 'DIFXROOT'], \
	[], \
	remove \
]

command_openmpi = \
[ \
	'openmpi', \
	'Download (if needed), compile, and install openmpi version %s' % openmpiVersion, \
	['DIFX_BASE'], \
	[], \
	openmpi \
]

commands = \
[ \
	command_list, \
	command_bootstrap, \
#	command_default, \
	command_svn, \
#	command_tar, \
	command_autotool, \
	command_build, \
	command_rebuild, \
	command_uninstall, \
#	command_remove, \
	command_openmpi, \
]


def run_command(commandName, args, verbose, pretend):
	command = None
	for c in commands:
		if c[0] == commandName:
			command = c
	if not command == None:
		hasEnviron = True
		hasParams = True
		for e in command[2]:
			if not environ.has_key(e):
				print 'Env. Var. %s needs to be set' % e
				hasEnviron = False
		nParam = len(command[3])
		params = {}
		if len(args) < nParam:
			print 'Two few arguments provided'
			hasParams = False
		else:
			for i in range(nParam):
				params[command[3][i]] = args[i]
		if hasEnviron and hasParams:
			if verbose > 1:
				print '  params=', params
				print '  extras=', args[nParam:]
				print '  pretend=', pretend
				print '  verbose=', verbose
				print ''
			print '=== Running command: %s ===\n' % command[0]
			command[4](components[environ['DIFX_VERSION']], params, args[nParam:], verbose, pretend)
		else:
			print 'Not going to run.'
			
	else:
		print 'Command "%s" not recognized.  Seek help.' % commandName


def usage(prog):
	print 'usage:  %s [options] <command> [<command arguments>]\n' % prog
	print 'The possible commands are:\n'
	for command in commands:
		print command[0]
		print '  %s\n' % command[1]

def main():
	if not environ.has_key('DIFX_VERSION'):
		print 'Env. Var. DIFX_VERSION needs to be set'
		exit(2)
	if not components.has_key(environ['DIFX_VERSION']):
		print 'This script is not set up to handle version %s' % environ['DIFX_VERSION']
		exit(2)
	try:
		opts, args = getopt.getopt(argv[1:], "hqvp", ["help", "quiet", "verbose", "pretend"])
	except getopt.GetoptError, err:
		print '%s\n' % str(err)
		usage(argv[0])
		exit(2)
	verbose = 1
	pretend = False
	for o, a in opts:
		if o == '-v':
			verbose += 1
		elif o == '-q':
			verbose -= 1
		elif o == '-h':
			usage(argv[0])
			exit(0)
		elif o == '-p':
			pretend = True

	if len(args) <= 0:
		usage(argv[0])
		exit(0)
		
	run_command(args[0], args[1:], verbose, pretend)

#----

if __name__ == "__main__":
	main()
