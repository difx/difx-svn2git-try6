#!/bin/env python

from os import environ, system, getcwd, chdir
from os.path import isdir, isfile
from sys import argv, exit
import getopt
from string import split


def execute(cmd, verbose, pretend):
	if pretend:
		print '%s# %s' % (getcwd(), cmd)
	else:
		if verbose:
			print 'In: %s   Executing: %s' % (getcwd(), cmd)
		system(cmd)
def checkDirs(comps, dir, args):
	okComps = []
	for comp in comps:
		path = dir + comp[0] + '/'
		if not isdir(path):
			if 'ok' in args:
				print 'Warning: %s does not exist.  Skipping.' % path
			else:
				print 'Error: %s does not exist.  Stopping.' % path
		else:
			okComps.append(comp)

	if not 'ok' in args and len(comps) != len(okComps):
		okComps = []

	return okComps

def checkFiles(comps, dir, fileName, args):
	okComps = []
	for comp in comps:
		file = dir + comp[0] + '/' + fileName
		if not isfile(file):
			if 'ok' in args:
				print 'Warning: %s does not exist.  Skipping.' % file
			else:
				print 'Error: %s does not exist.  Stopping.' % file
		else:
			okComps.append(comp)

	if not 'ok' in args and len(comps) != len(okComps):
		okComps = []

	return okComps

def componentList(comps):
	i = 0
	str = ''
	for c in comps:
		if i > 0:
			str += ', '
		str += c[0]
		i += 0
	return str

def filterComponents(origComps, args):
	if 'cwd' in args:
		local = split(getcwd(), '/')[-2:]
	else:
		local = []
	
	comps = []
	for c in origComps:
		if c[0] in local or c[0] in args:
			comps.append(c)
	if len(comps) == 0:
		if 'cwd' in args:
			print "Error: cannot build in local directory: don't know where I am!"
		else:
			comps = origComps
	return comps

components = {}	# indexed by ${DIFX_VERSION}

# components each have the following elements:
# [
#	0 name
#	1 svn path
#	2 [build flags]
# ]

component_difxio_trunk = \
[ \
	'difxio', \
	'https://svn.atnf.csiro.au/difx/libraries/difxio/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_difxmessage_trunk = \
[ \
	'difxmessage', \
	'https://svn.atnf.csiro.au/difx/libraries/difxmessage/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_mark5access_trunk = \
[ \
	'mark5access', \
	'https://svn.atnf.csiro.au/difx/libraries/mark5access/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_vdifio_trunk = \
[ \
	'vdifio', \
	'https://svn.atnf.csiro.au/difx/libraries/vdifio/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

component_mpifxcorr_trunk = \
[ \
	'mpifxcorr', \
	'https://svn.atnf.csiro.au/difx/mpifxcorr/trunk', \
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx', 'ipp'] \
]

component_difx2fits_trunk = \
[ \
	'difx2fits', \
	'https://svn.atnf.csiro.au/difx/applications/difx2fits/trunk' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'], \
]

component_vex2difx_trunk = \
[ \
	'vex2difx', \
	'https://svn.atnf.csiro.au/difx/applications/vex2difx/trunk' ,\
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'], \
]

components['DIFX_DEVEL'] = \
[ \
	component_difxio_trunk, \
	component_difxmessage_trunk, \
	component_mpifxcorr_trunk, \
	component_vdifio_trunk, \
	component_mpifxcorr_trunk, \
	component_difx2fits_trunk, \
	component_vex2difx_trunk, \
]

# commands each have the following elements:
# [
#	0 Name
#	1 Description
#	2 Needed env variables
#	3 Command line values
#	4 Function to call
# ]

def list(comps, params, args, verbose, pretend):
	print 'Components being managed for %s are:' % environ['DIFX_VERSION']
	for c in comps:
		print '  %s' % c[0]
	print ''

def svnupdate(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	srcDir = environ['DIFX_SRC'] + '/'
	if not isdir(srcDir):
		execute('mkdir -p %s' % srcDir, verbose, pretend);
		
	for comp in comps:
		path = srcDir + comp[0] + '/'
		if isdir(path):
			chdir(path)
			cmd = 'svn update'
		else:
			chdir(srcDir)
			cmd = 'svn co %s %s' % (comp[1], comp[0])
		execute(cmd, verbose, pretend)

def autotool(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	srcDir = environ['DIFX_SRC'] + '/'
	okComps = checkDirs(comps, srcDir, args)
	if verbose > 1:
		print 'Autotooling: %s' % componentList(okComps)
	for comp in okComps:
		path = srcDir + comp[0] + '/'
		chdir(path)
		buildFlags = comp[2]
		if 'aclocal' in buildFlags:
			execute('aclocal', verbose, pretend)
		if 'libtoolize' in buildFlags:
			execute('libtoolize --copy --force', verbose, pretend)
		if 'autoconf' in buildFlags:
			execute('autoconf', verbose, pretend)
		if 'autoheader' in buildFlags:
			execute('autoheader', verbose, pretend)
		if 'automake' in buildFlags:
			execute('automake -a', verbose, pretend)

def build(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	srcDir = environ['DIFX_SRC'] + '/'
	okComps = checkDirs(comps, srcDir, args)
	if len(okComps) > 0:
		if verbose > 1:
			print 'Building: %s' % componentList(okComps)
		if not isdir(buildDir):
			execute('mkdir -p %s' % buildDir, verbose, pretend)
		for comp in okComps:
			srcPath = srcDir + comp[0] + '/'
			buildPath = buildDir + comp[0] + '/'
			if not isdir(buildPath):
				execute('mkdir -p %s' % buildPath, verbose, pretend)
			chdir(buildPath)
			if not 'noconf' in args:
				buildFlags = comp[2]
				configureExtras = ''
				if 'mpicxx' in buildFlags:
					configureExtras += ' CXX=${MPICXX}'
				cmd = '%s/configure --prefix=${DIFXROOT}%s' % (srcPath, configureExtras)
				execute(cmd, verbose, pretend)
			execute('make -j 3', verbose, pretend)
			execute('make install', verbose, pretend)
			
def rebuild(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	if verbose > 1:
		print 'Rebuilding: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('make -j 3', verbose, pretend)
			execute('make install', verbose, pretend)
			
def uninstall(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	okComps.reverse()	# best done in reverse for reasons of dependency
	if verbose > 1:
		print 'Uninstalling: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('make uninstall', verbose, pretend)

def remove(origComps, params, args, verbose, pretend):
	print 'Feature not yet implemented'




command_list = \
[ \
	'list', \
	'List the components managed by this script for this DiFX version', \
	[], \
	[], \
	list \
]

command_svn = \
[ \
	'svn', \
	'Checkout or update from svn repository', \
	['DIFX_SRC'], \
	[], \
	svnupdate \
]

command_autotool = \
[ \
	'autotool', \
	'Prepare source directory for configuring', \
	['DIFX_SRC'], \
	[], \
	autotool \
]

command_build = \
[ \
	'build', \
	'Optionally run configure for each component then build/install', \
	['DIFX_SRC', 'DIFXROOT', 'MPICXX'], \
	[], \
	build \
]

command_uninstall = \
[ \
	'uninstall', \
	'Uninstall each component but leave source and build directories in tact', \
	['DIFXROOT'], \
	[], \
	uninstall \
]

command_remove = \
[ \
	'remove', \
	'Uninstall each component and remove source and build directories', \
	['DIFX_SRC', 'DIFXROOT'], \
	[], \
	remove \
]

commands = \
[ \
	command_list, \
	command_svn, \
#	command_tar, \
	command_autotool, \
	command_build, \
	command_uninstall, \
#	command_remove, \
]


def run_command(commandName, args, verbose, pretend):
	command = None
	for c in commands:
		if c[0] == commandName:
			command = c
	if not command == None:
		print '=== Running command: %s ===\n' % command[0]
		hasEnviron = True
		hasParams = True
		for e in command[2]:
			if not environ.has_key(e):
				print 'Env. Var. %s needs to be set' % e
				hasEnviron = False
		nParam = len(command[3])
		params = {}
		if len(args) < nParam:
			print 'Two few arguments provided'
			hasParams = False
		else:
			for i in range(nParam):
				params[command[3][i]] = args[i]
		if hasEnviron and hasParams:
			if verbose > 1:
				print '  params=', params
				print '  extras=', args[nParam:]
				print '  pretend=', pretend
				print '  verbose=', verbose
				print ''
			command[4](components[environ['DIFX_VERSION']], params, args[nParam:], verbose, pretend)
		else:
			print 'Not going to run.'
			
	else:
		print 'Command "%s" not recognized.  Seek help.' % commandName


def usage(prog):
	print 'usage:  %s [options] <command> [<command arguments>]\n' % prog
	print 'The possible commands are:\n'
	for command in commands:
		print command[0]
		print '  %s\n' % command[1]

def main():
	if not environ.has_key('DIFX_VERSION'):
		print 'Env. Var. DIFX_VERSION needs to be set'
		exit(2)
	if not components.has_key(environ['DIFX_VERSION']):
		print 'This script is not set up to handle version %s' % environ['DIFX_VERSION']
		exit(2)
	try:
		opts, args = getopt.getopt(argv[1:], "hqvp", ["help", "quiet", "verbose", "pretend"])
	except getopt.GetoptError, err:
		print '%s\n' % str(err)
		usage(argv[0])
		exit(2)
	verbose = 1
	pretend = False
	for o, a in opts:
		if o == '-v':
			verbose += 1
		elif o == '-q':
			verbose -= 1
		elif o == '-h':
			usage(argv[0])
			exit(0)
		elif o == '-p':
			pretend = True

	if len(args) <= 0:
		usage(argv[0])
		exit(0)
		
	run_command(args[0], args[1:], verbose, pretend)

#----

if __name__ == "__main__":
	main()
